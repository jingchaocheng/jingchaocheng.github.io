<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jingchao&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.chengjingchao.com/"/>
  <updated>2022-01-03T14:02:39.899Z</updated>
  <id>https://www.chengjingchao.com/</id>
  
  <author>
    <name>Jingchao Cheng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TypeScript 编程</title>
    <link href="https://www.chengjingchao.com/2022/01/01/TypeScript-%E7%BC%96%E7%A8%8B/"/>
    <id>https://www.chengjingchao.com/2022/01/01/TypeScript-%E7%BC%96%E7%A8%8B/</id>
    <published>2022-01-01T12:41:28.000Z</published>
    <updated>2022-01-03T14:02:39.899Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第-1-章-导言"><a href="#第-1-章-导言" class="headerlink" title="第 1 章 导言"></a>第 1 章 导言</h1><p>使用 TypeScript 开发的程序<strong>更安全</strong>，常见的错误都能检查出来，写出的代码还可以作为文档。</p><p>更安全是指<strong>类型安全</strong></p><blockquote><p>类型安全：借助类型避免程序做无效的事情（无效指的是运行时程序崩溃或未崩溃，但做的事情毫无意义</p></blockquote><p>举个 🌰</p><ul><li>数字乘以一个列表</li><li>接收数字的函数却传入了字符串</li><li>调用对象上不存在的方法</li><li>导入已经被移除的模块<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> + [] <span class="comment">// "3"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">obj.foo <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> b/<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">a(<span class="string">'z'</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure></li></ul><p>在做无效事情的时候，JavaScript 没有抛出异常，而是尽自己所能，避免抛出异常。</p><p>而 JavaScript 这种特性让代码中<strong>错误的产生与发现脱节</strong>了。导致 bug 往往是由他人转告给你的。<br>到真正运行时可能才会发现错误。</p><p>而 TypeScript 给出错误的时间点：在输入代码的过程中，代码编辑器会给出错误消息，来提醒你。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> + [] <span class="comment">// Error TS2365: Operator '+' cannot be applied to types '3' and 'never[]'.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">obj.foo <span class="comment">// Error TS2339: Property 'foo' does not exist on type '&#123;&#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">a: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> b / <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">a(<span class="string">'z'</span>) <span class="comment">// Error TS2345: Argument of type '"z"' is not assignable to parameter of type 'number'.</span></span><br></pre></td></tr></table></figure><h1 id="第-2-章-TypeScript-概述"><a href="#第-2-章-TypeScript-概述" class="headerlink" title="第 2 章 TypeScript 概述"></a>第 2 章 TypeScript 概述</h1><h2 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h2><p>TypeScript 编译器（TSC）</p><p>通常运行程序的大致流程</p><ol><li>把程序解析为 AST</li><li>AST 编译成字节码</li><li>运行时计算字节码</li></ol><p>运行程序就是让运行时计算由编译器从源码解析得来的 AST 生成的字节码。</p><p>TypeScript 的特殊之处在于，不直接编译成字节码，而是编译成 JavaScript。然后再像往常一样，在浏览器/NodeJS 中运行。</p><p>TypeScript 编译器生成 AST 之后，真正运行代码之前会对代码做类型检查。</p><blockquote><p>类型检查器：检查代码是否符合安全要求的特殊程序</p></blockquote><p>编译和运行 TypeScript (1-3 由 TSC 操作，4-6 由浏览器/NodeJS 操作)</p><ol><li>TypeScript 源码 -&gt; TypeScript AST</li><li>类型检查器检查 AST</li><li>TypeScript AST -&gt; JavaScript 源码</li></ol><ol start="4"><li>JavaScript 源码 -&gt; JavaScript AST</li><li>AST -&gt; 字节码</li><li>运行时计算字节码</li></ol><p>类型只在类型检查这一步使用，TSC 把 TS 编译成 JS 时，不会考虑类型。可以确保可以随意改动、更新和改进程序中的类型，而无需担心会破坏应用的功能。</p><h2 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h2><blockquote><p>类型系统：类型检查器为程序分配类型时使用的一系列规则</p></blockquote><p>一般来说，类型系统有两种，各有利弊</p><ol><li>通过显式句法告诉编译器所有值的类型</li><li>自动推导值的类型</li></ol><p>JavaScript 在运行时推导类型<br>TypeScript 身兼两种类型系统，可以显式注解类型，也可以自动推导多数类型。</p><p>显示声明类型需要使用注解。注解的形式 <code>value: type</code>，就像是告诉类型检查器，“嘿，看到这个 value 了吗？它的类型是 type。”</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显示注解</span></span><br><span class="line"><span class="keyword">let</span> a: <span class="built_in">number</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> b: <span class="built_in">string</span> = <span class="string">'hello'</span></span><br><span class="line"><span class="keyword">let</span> c: <span class="built_in">boolean</span>[] = [<span class="literal">true</span>, <span class="literal">false</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动推导</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="string">'hello'</span></span><br><span class="line"><span class="keyword">let</span> c = [<span class="literal">true</span>, <span class="literal">false</span>]</span><br></pre></td></tr></table></figure><h3 id="TypeScript-VS-JavaScript"><a href="#TypeScript-VS-JavaScript" class="headerlink" title="TypeScript VS JavaScript"></a>TypeScript VS JavaScript</h3><table><thead><tr><th>类型系统特性</th><th>JavaScript</th><th>TypeScript</th></tr></thead><tbody><tr><td>类型是如何绑定的？</td><td>动态</td><td>静态</td></tr><tr><td>是否自动转换类型？</td><td>是</td><td>否（多数时候）</td></tr><tr><td>何时检查类型？</td><td>运行时</td><td>编译时</td></tr><tr><td>何时报告错误？</td><td>运行时（多数时候）</td><td>编译时（多数时候）</td></tr></tbody></table><p>TypeScript 能做的是把纯 JavaScript 代码中那些运行时愈发和类型相关的错误提前到编译时报告。在代码编辑器中显示，输入代码后立即就有反馈。</p><p>类型是如何绑定的？<br>JavaScript 动态绑定类型，必须运行程序才能知道类型。<br>TypeScript 渐进式类型语言，在编译时知道所有类型</p><h1 id="第-3-章-类型全解"><a href="#第-3-章-类型全解" class="headerlink" title="第 3 章 类型全解"></a>第 3 章 类型全解</h1><blockquote><p>类型：一系列值及对其执行的操作</p></blockquote><p>example</p><table><thead><tr><th>类型</th><th>包含的值</th><th>可以执行的操作</th></tr></thead><tbody><tr><td>boolean</td><td>true、false</td><td>&#124;&#124;、&amp;&amp;、!</td></tr><tr><td>number</td><td>所有数字</td><td>+、-、*、/、%、&amp;&amp;、?  .toFixed()、.toString()</td></tr><tr><td>string</td><td>所有字符串</td><td>+、&#124;&#124;、&amp;&amp;  .concat()、.toUpperCase()</td></tr></tbody></table><p>对 T 类型的值来说，我们不仅知道值的类型是 T，还知道可以/不可以对该值做什么操作。<br>类型检查器通过使用的类型和具体用法判断是否有效。</p><p>TypeScript 的类型层次结构<br><img src="/img/typescript/type.jpeg" alt="TypeScript 的类型层次结构"></p><h2 id="类型术语"><a href="#类型术语" class="headerlink" title="类型术语"></a>类型术语</h2><ul><li>类型注解（可以理解为某种界限<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">squareOf</span>(<span class="params">n: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n * n;</span><br><span class="line">&#125;</span><br><span class="line">squareOf(<span class="number">2</span>); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="类型浅谈"><a href="#类型浅谈" class="headerlink" title="类型浅谈"></a>类型浅谈</h2><h3 id="any"><a href="#any" class="headerlink" title="any"></a>any</h3><p>在 TypeScript 中，编译时一切都要有类型，如果你和 TypeScript（类型检查器）无法确认类型是什么，默认为 any。这是兜底类型，应该尽量避免使用。</p><p>类型的定义（一系列值及可以对其执行的操作）any 包含所有值，而且可以对其做什么操作。any 类型的值就像常规的 JavaScript 一样，类型检查器完全发挥不了作用。</p><p>使用 any 需要显示注解。</p><p>tsconfig.json<br>noImplicitAny: true;</p><p>noImplicitAny 隶属于 TSC 的 strict 标志家族，</p><h3 id="unknown"><a href="#unknown" class="headerlink" title="unknown"></a>unknown</h3><p>unknown 与 any 类似，也表示任何值。但是 TypeScript 会要求你在做检查，细化类型。</p><table><thead><tr><th>类型</th><th>包含的值</th><th>可以执行的操作</th></tr></thead><tbody><tr><td>unknown</td><td></td><td><code>==</code>、<code>===</code>、<code>||</code>、<code>&amp;&amp;</code>、<code>?</code>、<code>!</code>、<code>typeof</code>、<code>instance of</code></td></tr></tbody></table><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example</span></span><br><span class="line"><span class="keyword">let</span> a: unknown = <span class="number">30</span>; <span class="comment">// unknown</span></span><br><span class="line"><span class="keyword">let</span> b = a === <span class="number">123</span>; <span class="comment">// boolean</span></span><br><span class="line"><span class="keyword">let</span> c = a + <span class="number">10</span>; <span class="comment">// Error TS 2571: Object is of type 'unknown'</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="string">'number'</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> d = a + <span class="number">10</span>; <span class="comment">// number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>unknown 的用法</p><ol><li>TypeScript 不会把任何值推导为 unknown 类型，必须显示注解（a）</li><li>unknown 类型的值可以比较（b）</li><li>执行操作时不能假定 unknown 类型的值为某种特定类型（c），必须先向 TypeScript 证明一个值确实是某个类型（d）</li></ol><h3 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h3><table><thead><tr><th>类型</th><th>包含的值</th><th>可以执行的操作</th></tr></thead><tbody><tr><td>boolean</td><td><code>true</code>、<code>false</code></td><td><code>==</code>、<code>===</code>、<code>||</code>、<code>&amp;&amp;</code>、<code>?</code></td></tr></tbody></table><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="literal">true</span>                <span class="comment">// boolean</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">false</span>               <span class="comment">// boolean</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="literal">true</span>              <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> d: <span class="built_in">boolean</span> = <span class="literal">true</span>       <span class="comment">// boolean</span></span><br><span class="line"><span class="keyword">let</span> e: <span class="literal">true</span> = <span class="literal">true</span>          <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> f: <span class="literal">true</span> = <span class="literal">false</span>         <span class="comment">// Error TS2322: Type 'false' is not assignable to type 'true'.</span></span><br></pre></td></tr></table></figure><ol><li>TypeScript 推导出值的类型为 boolean（a 和 b）</li><li>使用 const，让 TypeScript 推导出值为某个具体的布尔值（c）</li><li>显式注解，声明值的类型为 boolean（d）</li><li>显式注解，声明值为某个具体的布尔值（e 和 f）。把类型设定为某个值，就限制了 e 和 f 在所有布尔值中只能取指定的那个值。这种特性被称为类型字面量。</li></ol><blockquote><p>类型字面量——仅表示一个值的类型</p></blockquote><p>变量 e f 是使用类型字面量显示注解了变量，变量 c 则是由 TypeScript 推导出一个字面量类型，因为使用的是 const。<br>const 声明的基本类型的值，赋值之后无法修改，因此 TypeScript 推导出的是范围最窄的类型，所以 TypeScript 推导出的 c 的类型为 true，而不是 boolean。</p><h3 id="number"><a href="#number" class="headerlink" title="number"></a>number</h3><table><thead><tr><th>类型</th><th>包含的值</th><th>可以执行的操作</th></tr></thead><tbody><tr><td>number</td><td>整数、浮点数、正数、负数、Infinity、NaN 等</td><td>算术运算 比较</td></tr></tbody></table><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1234</span>                  <span class="comment">// number</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="literal">Infinity</span> * <span class="number">0.1</span>        <span class="comment">// number</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="number">5678</span>                <span class="comment">// 5678</span></span><br><span class="line"><span class="keyword">let</span> d = a &lt; b                 <span class="comment">// boolean</span></span><br><span class="line"><span class="keyword">let</span> e: <span class="built_in">number</span> = <span class="number">100</span>           <span class="comment">// number</span></span><br><span class="line"><span class="keyword">let</span> f: <span class="number">26.218</span> = <span class="number">26.218</span>        <span class="comment">// 26.218</span></span><br><span class="line"><span class="keyword">let</span> g: <span class="number">26.218</span> = <span class="number">10</span>            <span class="comment">// Error TS2322: Type '10' is not assignable to type '26.218'</span></span><br></pre></td></tr></table></figure><ol><li>TypeScript 推导出值的类型为 number（a 和 b）</li><li>使用 const，让 TypeScript 推导出值为某个具体的数字（c）</li><li>显式注解，声明值的类型为 number（e）</li><li>显式注解，声明值为某个具体的数字（f 和 g）</li></ol><p>tips：处理较长的数字时可以使用数字分隔符。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> oneMillion = <span class="number">1</span>_000_ <span class="number">000</span>    <span class="comment">// 等同于 1000000</span></span><br><span class="line"><span class="keyword">let</span> twoMillion: <span class="number">2</span>_000_000 = <span class="number">2</span>_000_000</span><br></pre></td></tr></table></figure><h3 id="bigint"><a href="#bigint" class="headerlink" title="bigint"></a>bigint</h3><blockquote><p>是 JavaScript 和 TypeScript 新引入的类型，在处理较大的整数时，不用再担心舍入误差。</p></blockquote><p>number 类型表示的整数最大为 2<sup>53</sup>，bigint 可以表示任意大的整数。</p><table><thead><tr><th>类型</th><th>包含的值</th><th>可以执行的操作</th></tr></thead><tbody><tr><td>bigint</td><td>所有 BigInt 数</td><td>算术运算 比较</td></tr></tbody></table><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1234n</span>                  <span class="comment">// bigint</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="number">5678n</span>                <span class="comment">// 5678n</span></span><br><span class="line"><span class="keyword">let</span> c = a + b                  <span class="comment">// bigint</span></span><br><span class="line"><span class="keyword">let</span> d = a &lt; <span class="number">1235</span>               <span class="comment">// boolean</span></span><br><span class="line"><span class="keyword">let</span> e = <span class="number">88.5n</span>                  <span class="comment">// Error TS1353: A bigint literal must be an integer.</span></span><br><span class="line"><span class="keyword">let</span> f: bigint = <span class="number">100n</span>           <span class="comment">// bigint</span></span><br><span class="line"><span class="keyword">let</span> g: <span class="number">100n</span> = <span class="number">100n</span>             <span class="comment">// 100n</span></span><br><span class="line"><span class="keyword">let</span> h: bigint = <span class="number">100</span>            <span class="comment">// Error TS2322: Type '100' is not assignable ty type 'bigint'.</span></span><br></pre></td></tr></table></figure><p>与 boolean 和 number 一样，声明 bigint 类型也有四种方式。尽量让 TypeScript 自动推导。</p><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><table><thead><tr><th>类型</th><th>包含的值</th><th>可以执行的操作</th></tr></thead><tbody><tr><td>string</td><td>所有字符串</td><td>字符串可以进行的操作 例如 +、.slice()</td></tr></tbody></table><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="string">'hello'</span>                 <span class="comment">// string</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="string">'billy'</span>                 <span class="comment">// string</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="string">'!'</span>                   <span class="comment">// !</span></span><br><span class="line"><span class="keyword">let</span> d = a + <span class="string">' '</span> + b + c         <span class="comment">// string</span></span><br><span class="line"><span class="keyword">let</span> e: <span class="built_in">string</span> = <span class="string">'zoom'</span>          <span class="comment">// string</span></span><br><span class="line"><span class="keyword">let</span> f: <span class="string">'john'</span> = <span class="string">'john'</span>          <span class="comment">// john</span></span><br><span class="line"><span class="keyword">let</span> g: <span class="string">'john'</span> = <span class="string">'zoe'</span>           <span class="comment">// Error TS2322: Type 'zoe' is not assignable to type 'john'</span></span><br></pre></td></tr></table></figure><p>同样也是尽量让 TypeScript 自动推导 string 类型。</p><h3 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h3><p>symbol 经常用于代替对象和映射的字符串健，防止被意外设置。<br>symbol 的类型就是 symbol，每一个 symbol 都是唯一的，不与其他任何符号相等，即便再使用相同的名称创建一个 symbol 也是如此。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example</span></span><br><span class="line"><span class="keyword">let</span> a = Symbol(<span class="string">'a'</span>)              <span class="comment">// symbol</span></span><br><span class="line"><span class="keyword">let</span> b: symbol = Symbol(<span class="string">'b'</span>)      <span class="comment">// symbol</span></span><br><span class="line"><span class="keyword">let</span> c = a === b                  <span class="comment">// boolean</span></span><br><span class="line"><span class="keyword">let</span> d = a + <span class="string">'x'</span>                  <span class="comment">// Error TS2469: The '+' operator cannot be applied to type 'symbol'.</span></span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example</span></span><br><span class="line"><span class="keyword">const</span> e = Symbol(<span class="string">'e'</span>)                  <span class="comment">// unique symbol</span></span><br><span class="line"><span class="keyword">const</span> f: unique symbol = Symbol(<span class="string">'f'</span>)   <span class="comment">// unique symbol</span></span><br><span class="line"><span class="keyword">let</span> g: unique symbol = Symbol(<span class="string">'f'</span>)     <span class="comment">// Error TS1332: A variable whose type is a 'unique symbol' type must be 'const'.</span></span><br><span class="line"><span class="keyword">let</span> h = e === e                        <span class="comment">// boolean</span></span><br><span class="line"><span class="keyword">let</span> i = e === f                        <span class="comment">// Error TS2367: This condition will always return 'false' since the type 'unique symbol' and 'unique symbol' have no overlap.</span></span><br></pre></td></tr></table></figure><p>创建 symbol 的方式</p><ol><li>使用 const，TypeScript 会推导为 unique symbol 类型。</li><li>显式注解 const 变量的类型为 unique symbol</li><li>unique symbol 类型的值始终与自身相等</li><li>TypeScript 在编译时知道一个 unique symbol 绝对不会与另一个 unique symbol  相等</li></ol><p>unique symbol 与其他字面量类型其实是一样的。</p><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>TypeScript 的对象类型表示对象的结构。</p><blockquote><p>结构化类型–一种编程设计风格，只关心对象有哪些属性，而不管属性使用什么名称（名义化类型）。在某些语言中也叫鸭子类型（即不以貌取人）</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example</span></span><br><span class="line"><span class="keyword">let</span> b: object = &#123;</span><br><span class="line">  b: <span class="string">'x'</span></span><br><span class="line">&#125;</span><br><span class="line">a.b <span class="comment">// Error TS2339: Property 'b' does not exist on type 'object'.</span></span><br></pre></td></tr></table></figure><p>object 只能表示该值是一个 JavaScript 对象（而且不是 null）</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象字面量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动推导</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  b: <span class="string">'x'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">let</span> a: &#123; b: <span class="built_in">string</span> &#125; = &#123;</span><br><span class="line">  b: <span class="string">'x'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对象字面量句法的意思是，“这个东西的结构是这样过的。”</p><p>使用 const 声明对象不会导致 TypeScript 把推导的类型缩窄。与上面的基本类型不同。这是因为 JavaScript 对象是可变的，所以在 TypeScript 看来，创建对象之后你可能会更新对象的字段。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: &#123; b: <span class="built_in">number</span> &#125;</span><br><span class="line">b = &#123;&#125; <span class="comment">// Error TS2741: Property 'b' is missing in type '&#123;&#125;' but required in type '&#123;b: number&#125;'.</span></span><br><span class="line"></span><br><span class="line">b = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span></span><br><span class="line">&#125; <span class="comment">// Error TS2322: Type '&#123;b: number; c: number&#125;' is not assignable to type '&#123;b: number&#125;'. Object literal may only specify known properties, and 'c' does not exist in type '&#123;b: number&#125;'.</span></span><br></pre></td></tr></table></figure><p>默认情况下，TypeScript 对对象的属性要求十分严格。如果声明对象有个类型为 number 的属性 b，TypeScript 将预期对象有且只有这个属性。缺少或者多了，TypeScript 都会报错。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: &#123;</span><br><span class="line">  b: <span class="built_in">number</span></span><br><span class="line">  c?: <span class="built_in">string</span>        <span class="comment">// 可能有个类型为 string 的属性 c。其值可以为 undefined</span></span><br><span class="line">  readonly firstName: <span class="built_in">string</span> <span class="comment">// 为字段赋初始值后无法修改。类似于使用 const 声明对象的属性</span></span><br><span class="line">  [key: <span class="built_in">number</span>]: <span class="built_in">boolean</span> <span class="comment">// 可能有任意多个数字属性，其值为布尔值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>[key: T]: U</code> 句法称为索引签名，通过这种方式告诉 TypeScript，指定的对象可能有更多的 key。这种句法的意思是，“在这个对象中，类型为 T 的健对应的值为 U 类型。”</p></blockquote><ul><li>索引签名 key 的类型 T 必须可赋值给 number 或 string。（JavaScript 对象的健为字符串；数组是特殊的对象，健为数字。）</li><li>key 的名称可以是任意词，不一定非的用 key</li></ul><p>对象字面量表示法有一个特例：空对象类型 <code>{}</code>。除 null 和 undefined 之外的任何类型都可以赋值给空对象类型，应该尽量避免使用。</p><p>在 TypeScript 中声明对象类型有四种方式</p><ol><li>对象字面量表示法 <code>{a: string}</code>，也称对象结构</li><li>空对象字面量表示法 <code>{}</code>。避免使用</li><li>object 类型。如果需要个对象，当对这个对象的字段没有要求，使用这种方式。</li><li>Object。避免使用</li></ol><p>对一个值，在类型允许的情况下，可以对其执行特定的操作。其实在类型自身上也可以执行一些操作。<br>类型别名</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Age = <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person = &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  age: Age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> driver: Person = &#123;</span><br><span class="line">  name: <span class="string">'Jack'</span></span><br><span class="line">  age: <span class="number">18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型别名采用块级作用域。在同一作用于中不能重复声明相同类型。</p><p>并集和交集</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Cat = &#123; name: <span class="built_in">string</span>, purrs: <span class="built_in">boolean</span> &#125;</span><br><span class="line"><span class="keyword">type</span> Dog =&#123; name: <span class="built_in">string</span>, barks: <span class="built_in">boolean</span>, wags: <span class="built_in">boolean</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CatOrDogOrBoth = Cat | Dog <span class="comment">// 并集</span></span><br><span class="line"><span class="keyword">type</span> CatAndDog = Cat &amp; Dog <span class="comment">// 交集</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// CatOrDogOrBoth 可以是 Cat 类型的值，可以是 Dog 类型的值，还可以二者兼具。</span></span><br><span class="line"><span class="comment">// Cat</span></span><br><span class="line"><span class="keyword">let</span> a: CatOrDogOrBoth = &#123;</span><br><span class="line">  name: <span class="string">'Bonkers'</span>,</span><br><span class="line">  purrs: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dog</span></span><br><span class="line">a = &#123;</span><br><span class="line">  name: <span class="string">'Domino'</span>,</span><br><span class="line">  barks: <span class="literal">true</span>,</span><br><span class="line">  wags: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二者兼具</span></span><br><span class="line">a = &#123;</span><br><span class="line">  name: <span class="string">'Donkers'</span>,</span><br><span class="line">  barsk: <span class="literal">true</span>,</span><br><span class="line">  purrs: <span class="literal">true</span>,</span><br><span class="line">  wags: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CatAndDot</span></span><br><span class="line"><span class="keyword">let</span> b: CatAndDog = &#123;</span><br><span class="line">  name: <span class="string">'Domino'</span>,</span><br><span class="line">  barks: <span class="literal">true</span>,</span><br><span class="line">  purrs: <span class="literal">true</span>,</span><br><span class="line">  wags: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并集通常更常用</p><ul><li>函数返回值可能是一个字符串，也可能是 null。<code>string | null</code></li><li>混合类型的数组</li></ul><p>数组</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]                <span class="comment">// number[]</span></span><br><span class="line"><span class="keyword">let</span> b = [<span class="string">'a'</span>, <span class="string">'b'</span>]               <span class="comment">// string[]</span></span><br><span class="line"><span class="keyword">let</span> c: <span class="built_in">string</span>[] = [<span class="string">'a'</span>]          <span class="comment">// string[]</span></span><br><span class="line"><span class="keyword">let</span> d = [<span class="number">1</span>, <span class="string">'a'</span>]                 <span class="comment">// (number | string)[]</span></span><br><span class="line"><span class="keyword">const</span> e = [<span class="number">2</span>, <span class="string">'b'</span>]               <span class="comment">// (number | string)[]</span></span><br><span class="line"><span class="keyword">let</span> f = [<span class="string">'red'</span>]                  <span class="comment">// string[]</span></span><br><span class="line"></span><br><span class="line">f.push(<span class="string">'blue'</span>)</span><br><span class="line">f.push(<span class="literal">true</span>)                     <span class="comment">// Error TS2345: Argument of type 'true' is not assignable to parameter of type 'string'.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> g = []                       <span class="comment">// any[]</span></span><br><span class="line">g.push(<span class="number">1</span>)                        <span class="comment">// number[]</span></span><br><span class="line">g.push(<span class="string">'red'</span>)                    <span class="comment">// (number | string)[]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> h: <span class="built_in">number</span>[] = []             <span class="comment">// number[]</span></span><br><span class="line">h.push(<span class="number">1</span>)                        <span class="comment">// number[]</span></span><br><span class="line">h.push(<span class="string">'red'</span>)                    <span class="comment">// Error TS2345: Argument of type '"red"' is not assignable to parameter of type 'number'.</span></span><br></pre></td></tr></table></figure><p>TypeScript 支持两种注解数组类型的句法</p><ol><li>T[]</li><li>Array<T></li></ol><p>一般情况下，数组应该保持同质。</p><p>元祖</p><blockquote><p>array 的子类型，长度固定，各索引位上的值具有固定的已知类型。</p></blockquote><p>声明元组时必须显式注解类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: [<span class="built_in">number</span>] = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> b: [<span class="built_in">string</span>, <span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="string">'jack'</span>, <span class="string">'boy'</span>, <span class="number">1963</span>]</span><br><span class="line">b = [<span class="string">'tom'</span>, <span class="string">'boy'</span>, <span class="string">'li'</span>, <span class="number">1926</span>] <span class="comment">// Error TS2322: Type 'string' is not assignable to type 'number'.</span></span><br></pre></td></tr></table></figure><p>元组也支持可选元素</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> trainFares: [<span class="built_in">number</span>, <span class="built_in">number</span>?][] = [</span><br><span class="line">  [<span class="number">3.75</span>],</span><br><span class="line">  [<span class="number">8.25</span>, <span class="number">7.70</span>],</span><br><span class="line">  [<span class="number">10.60</span>],</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">let</span> moreTrainFares: ([<span class="built_in">number</span>, <span class="built_in">number</span>] | [<span class="built_in">number</span>])[] = [</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>元组也支持剩余元素，即为元组定义最小长度</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串列表，至少有一个元素</span></span><br><span class="line"><span class="keyword">let</span> friends: [<span class="built_in">string</span>, ...string[]] = [<span class="string">'Sara'</span>, <span class="string">'Tali'</span>, <span class="string">'Chloe'</span>, <span class="string">'Claire'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元素类型不同的列表</span></span><br><span class="line"><span class="keyword">let</span> list: [<span class="built_in">number</span>, <span class="built_in">boolean</span>, ...string[]] = [<span class="number">1</span>, <span class="literal">false</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br></pre></td></tr></table></figure><p>只读数组和元祖</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">as</span>: readonly <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]     <span class="comment">// readonly number[]</span></span><br><span class="line"><span class="keyword">let</span> bs: readonly <span class="built_in">number</span>[] = <span class="keyword">as</span>.concat(<span class="number">4</span>)  <span class="comment">// readonly number[]</span></span><br><span class="line"><span class="keyword">let</span> three = bs[<span class="number">2</span>]                         <span class="comment">// number</span></span><br><span class="line"><span class="keyword">as</span>[<span class="number">4</span>] = <span class="number">5</span>                                 <span class="comment">// Error TS2542: Index signature in type 'readonly number[]' only permits reading.</span></span><br><span class="line"><span class="keyword">as</span>.push(<span class="number">6</span>)                                <span class="comment">// Error TS2339: Property 'push' does not exist on type 'readonly number[]'.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Readonly 和 ReadonlyArray 句法</span></span><br><span class="line"><span class="keyword">type</span> A = readonly <span class="built_in">string</span>[]                <span class="comment">// readonly string[]</span></span><br><span class="line"><span class="keyword">type</span> B = ReadonlyArray&lt;<span class="built_in">string</span>&gt;            <span class="comment">// readonly string[]</span></span><br><span class="line"><span class="keyword">type</span> C = Readonly&lt;<span class="built_in">string</span>[]&gt;               <span class="comment">// readonly string[]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> D = readonly [<span class="built_in">number</span>, <span class="built_in">string</span>]        <span class="comment">// readonly [number, string]</span></span><br><span class="line"><span class="keyword">type</span> E = Readonly&lt;[<span class="built_in">number</span>, <span class="built_in">string</span>]&gt;       <span class="comment">// readonly [number, string]</span></span><br></pre></td></tr></table></figure><p>null、undefined、void 和 never<br>| 类型 | 含义 |<br>| — | — |<br>| null | 缺少值 |<br>| undefined | 尚未赋值的变量 |<br>| void | 没有 return 语句的函数 |<br>| never | 永不返回的函数 |</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回 never 的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">d</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="built_in">TypeError</span>(<span class="string">'I always error'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">e</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    doSomething()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>never 是所有类型的子类型，可以赋值给其他任何类型。</p><p>枚举</p><blockquote><p>枚举的作用是列举类型中包含的各个值。是一种无序数据结构，把键映射到值上。</p></blockquote><p>枚举可以理解为编译时键固定的对象，访问键时，TypeScript 将检查指定的键是否存在。</p><p>枚举分为两种</p><ol><li>字符串到字符串之间的映射</li><li>字符串到数字之间的映射</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Language &#123;</span><br><span class="line">  English,</span><br><span class="line">  Spaish,</span><br><span class="line">  Russian</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>按约定，枚举名称为大写单数形式。枚举中的键也大写。</p></blockquote><p>TypeScript 可以自动为枚举中的各个成员推导对应的数字，也可以手动设置。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Language &#123;</span><br><span class="line">  English = <span class="number">0</span>,</span><br><span class="line">  Spanish = <span class="number">1</span>,</span><br><span class="line">  Russian = <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举中的值访问方式和对象一样</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myFirstLanguage = Language.Russian</span><br><span class="line"><span class="keyword">let</span> mySecondLanguage = Language[<span class="string">'English'</span>]</span><br></pre></td></tr></table></figure><p>一个枚举可以分成几次声明，TypeScript 将自动把各部分合并在一起</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Language &#123;</span><br><span class="line">  English = <span class="number">0</span>,</span><br><span class="line">  Spanish = <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Language &#123;</span><br><span class="line">  Russian = <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>meiju</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><table><thead><tr><th>类型</th><th>子类型</th></tr></thead><tbody><tr><td>boolean</td><td>Boolean 字面量</td></tr><tr><td>bigint</td><td>BigInt 字面量</td></tr><tr><td>number</td><td>Number 字面量</td></tr><tr><td>string</td><td>String 字面量</td></tr><tr><td>symbol</td><td>unique symbol</td></tr><tr><td>object</td><td>Object 字面量</td></tr><tr><td>数组</td><td>元组</td></tr><tr><td>enum</td><td>const enum</td></tr></tbody></table><h1 id="第-4-章-函数"><a href="#第-4-章-函数" class="headerlink" title="第 4 章 函数"></a>第 4 章 函数</h1><h2 id="声明和调用函数"><a href="#声明和调用函数" class="headerlink" title="声明和调用函数"></a>声明和调用函数</h2><p>在 JavaScript 中，函数是一等对象。这意味着，可以向对象那样使用函数</p><ol><li>可以赋值给变量</li><li>可以作为参数传给其他函数</li><li>可以作为函数的返回值</li><li>可以赋值给对象和原型</li><li>可以赋予属性</li><li>可以读取属性</li></ol><p>TypeScript 通常会显示注解函数的参数</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回类型能推导出来，不过也可以显示注解</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TypeScript 中声明函数</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具名函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">name: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'hello '</span> + name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">let</span> greet2 = <span class="function"><span class="keyword">function</span>(<span class="params">name: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  retunr <span class="string">'hello '</span> + name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数表达式</span></span><br><span class="line"><span class="keyword">let</span> greet3 = <span class="function">(<span class="params">name: <span class="built_in">string</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'hello '</span> + name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数表达式简写</span></span><br><span class="line"><span class="keyword">let</span> greet4 = <span class="function">(<span class="params">name: <span class="built_in">string</span></span>) =&gt;</span> <span class="string">'hello '</span> + name</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数构造方法</span></span><br><span class="line"><span class="keyword">let</span> greet5 = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'name'</span>, <span class="string">'return "hello " + name'</span>)</span><br></pre></td></tr></table></figure><p>除了函数构造方法，其他几种句法在 TypeScript 中都可以放心使用，能够保证类型安全。通常需要注解参数的类型，而返回类型不要求必须注解。<br>在调用函数时，TypeScript 将检查传入的实参是否于函数形参类型兼容。</p><h3 id="可选参数和默认参数"><a href="#可选参数和默认参数" class="headerlink" title="可选参数和默认参数"></a>可选参数和默认参数</h3><p>可选参数必须在末尾</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">message: <span class="built_in">string</span>, userId?: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> time = <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleTimeString()</span><br><span class="line">  <span class="built_in">console</span>.log(time, message, userId || <span class="string">'Not signed in'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log(<span class="string">'Page loded'</span>)</span><br><span class="line">log(<span class="string">'User signed in'</span>, <span class="string">'da763be'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认值参数（类似可选参数功能</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">message: <span class="built_in">string</span>, userId = 'Not signed <span class="keyword">in</span>'</span>) </span>&#123; <span class="comment">// userId 会自动推导类型</span></span><br><span class="line">  <span class="keyword">let</span> time = <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleTimeString()</span><br><span class="line">  <span class="built_in">console</span>.log(time, message, userId)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式注解默认参数类型</span></span><br><span class="line"><span class="keyword">type</span> Context = &#123;</span><br><span class="line">  appId?: <span class="built_in">string</span></span><br><span class="line">  userId?: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">message: <span class="built_in">string</span>, context: Context = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> time = <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleTimeString()</span><br><span class="line">  <span class="built_in">console</span>.log(time, message, context.userId)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认参数更常用，默认参数可以自动类型推导。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;!-- ### 剩余参数 --&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;!--</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>typescript</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>typescript</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>typescript</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>typescript</span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>typescript</span><br></pre></td></tr></table></figure><p> –&gt;</p><!-- # 第 5 章 类和接口# 第 6 章 类型进阶# 第 7 章 处理错误# 第 8 章 异步编程、并发和并行# 第 9 章 前后端框架# 第 10 章 命名空间和模块# 第 11 章 与 JavaScript 互操作# 第 12 章 构建和运行 TypeScript# 第 13 章 总结 -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第-1-章-导言&quot;&gt;&lt;a href=&quot;#第-1-章-导言&quot; class=&quot;headerlink&quot; title=&quot;第 1 章 导言&quot;&gt;&lt;/a&gt;第 1 章 导言&lt;/h1&gt;&lt;p&gt;使用 TypeScript 开发的程序&lt;strong&gt;更安全&lt;/strong&gt;，常见的错误都
      
    
    </summary>
    
    
    
      <category term="笔记" scheme="https://www.chengjingchao.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 函数式编程</title>
    <link href="https://www.chengjingchao.com/2021/12/19/JavaScript-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>https://www.chengjingchao.com/2021/12/19/JavaScript-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</id>
    <published>2021-12-19T14:03:33.000Z</published>
    <updated>2021-12-19T15:38:55.619Z</updated>
    
    <content type="html"><![CDATA[<p>本文是 <a href="https://www.youtube.com/watch?v=e-5obm1G_FY" target="_blank" rel="noopener">JSConf</a> 上的一篇笔记</p><h1 id="What-is-functional-programming"><a href="#What-is-functional-programming" class="headerlink" title="What is functional programming?"></a>What is functional programming?</h1><ul><li>一种编程范式 a programming paradigm</li><li>一种编码风格 a coding style</li><li>一种思考问题的方式 a mindset</li></ul><h1 id="Why-functional-JavaScript"><a href="#Why-functional-JavaScript" class="headerlink" title="Why functional JavaScript?"></a>Why functional JavaScript?</h1><ul><li>JS 的面向对象非常令人困惑</li><li>safer</li><li>easier to debug/maintain</li></ul><h1 id="要怎么做"><a href="#要怎么做" class="headerlink" title="要怎么做"></a>要怎么做</h1><p>函数式编程中你会想用函数来做所有事情，用函数来表达程序中的所有内容</p><p>接收输入 提供输出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Not functional</span></span><br><span class="line"><span class="comment"> 命令式风格 先做什么，再做什么，再最后做什么...</span></span><br><span class="line"><span class="comment"> 没有函数，不是以如何输入会转换为输出来表达</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'jack'</span>;</span><br><span class="line"><span class="keyword">var</span> greeting = <span class="string">"Hi, I'm "</span>;</span><br><span class="line"><span class="built_in">console</span>.log(greeting + name)</span><br><span class="line"></span><br><span class="line"><span class="comment">// functional</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Hi I'm "</span> + name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greet(<span class="string">'Anjana'</span>);</span><br></pre></td></tr></table></figure><h2 id="使用纯函数"><a href="#使用纯函数" class="headerlink" title="使用纯函数"></a>使用纯函数</h2><p>Avoid side effects<br>use “pure” functions</p><blockquote><p>副作用指当调用函数时，除了返回可能的函数值之外，还对主调用函数产生附加的影响。例如修改全局变量（函数外的变量），修改参数等。在某些情况下函数副作用会给程序设计带来不必要的麻烦，给程序带来十分难以查找的错误，并降低程序的可读性与可移植性。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Not pure</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'Anjana'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Hi, I'm "</span> + name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Use-Higher-order-Functions"><a href="#Use-Higher-order-Functions" class="headerlink" title="Use Higher-order Functions"></a>Use Higher-order Functions</h2><p>functions can be inputs/outputs</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeAdjectifier</span>(<span class="params">adjective</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">string</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> adjective + <span class="string">' '</span> + string;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> coolifier = makeAdjectifier(<span class="string">'cool'</span>);</span><br><span class="line">coolifier(<span class="string">'conference'</span>)</span><br></pre></td></tr></table></figure><h2 id="Don’t-iterate"><a href="#Don’t-iterate" class="headerlink" title="Don’t iterate"></a>Don’t iterate</h2><p>use map, reduce, filter<br>将函数提供给高阶函数得到想要的数据</p><p><del>for while do-while</del></p><h2 id="Avoid-mutability"><a href="#Avoid-mutability" class="headerlink" title="Avoid mutability"></a>Avoid mutability</h2><p>use immutable data</p><p>有时会意想不到的改变某些而导致的 bug。更好的方法就是将所有数据视为不可变的，永不改变。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mutation</span></span><br><span class="line"><span class="keyword">var</span> rooms = [<span class="string">'H1'</span>, <span class="string">'H2'</span>, <span class="string">'H3'</span>]</span><br><span class="line">rooms[<span class="number">2</span>] = <span class="string">'h4'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// No mutation</span></span><br><span class="line"><span class="keyword">var</span> rooms = [<span class="string">'H1'</span>, <span class="string">'H2'</span>, <span class="string">'H3'</span>]</span><br><span class="line"><span class="keyword">var</span> newRooms = rooms.map(<span class="function"><span class="keyword">function</span> (<span class="params">rm</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (rm === <span class="string">'H3'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'H4'</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> rm</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>不变性的问题在于，把数组和对象视为不可变的，每当需要进行一个小调整，先复制再修改。</p><h2 id="持久化数据结构"><a href="#持久化数据结构" class="headerlink" title="持久化数据结构"></a>持久化数据结构</h2><p><img src="/img/functinal/tree.jpg" alt=""><br>更改一小部分，重用旧的结构。结构共享，可以在新旧数据中共享某些部分。有更高的效率进行添加/修改。</p><ul><li>immutable.js</li></ul><h1 id="Q-amp-Q"><a href="#Q-amp-Q" class="headerlink" title="Q&amp;Q"></a>Q&amp;Q</h1><p>面向对象 VS 函数式编程<br>编程范式的哲学，没有一个范式比其他更好或更糟。<br>他们只是有不同的优点/缺点，和不同适用的情况，他们将成为最佳工具来解决某些问题。<br>如果你想快速地编写脚本就在你电脑上很快的运行一次，那么以命令式进行操作也是完全合法的.</p><p>取决于实际情况</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文是 &lt;a href=&quot;https://www.youtube.com/watch?v=e-5obm1G_FY&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JSConf&lt;/a&gt; 上的一篇笔记&lt;/p&gt;
&lt;h1 id=&quot;What-is-functional
      
    
    </summary>
    
    
    
      <category term="笔记" scheme="https://www.chengjingchao.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Send to Kindle for Chrome 使用教程</title>
    <link href="https://www.chengjingchao.com/2021/11/22/Send-to-Kindle-for-Chrome-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <id>https://www.chengjingchao.com/2021/11/22/Send-to-Kindle-for-Chrome-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</id>
    <published>2021-11-22T14:06:12.000Z</published>
    <updated>2021-11-22T14:47:45.004Z</updated>
    
    <content type="html"><![CDATA[<p>最近翻出了尘封许久的 Kindle 擦了擦灰，想起来一些偶尔在网络上看到的长篇文章推送到 Kindle 看也不错。<br>因为之前使用过，「亚马逊 Kindle 服务号」发送链接推送 Kindle，便发了个知乎的链接，在 Kindle 上打开乱码了。<br>在 Kindle for iOS 也是乱码。</p><p>之后搜了下其他方式看到 <a href="https://chrome.google.com/webstore/detail/send-to-kindle-for-google/cgdjpilhipecahhcilnafpblkieebhea?utm_source=chrome-ntp-icon" target="_blank" rel="noopener">Send to Kindle for Chrome</a> 也可以实现。</p><p>由于使用步骤不太顺利，这篇踩坑 Blog 就来了。</p><ol><li><p>安装 Chrome 插件 <a href="https://chrome.google.com/webstore/detail/send-to-kindle-for-google/cgdjpilhipecahhcilnafpblkieebhea?utm_source=chrome-ntp-icon" target="_blank" rel="noopener">Send to Kindle for Chrome</a></p></li><li><p>安装完成后点击插件打开 Settings，之后会打开个 <a href="https://www.amazon.com/sendtokindle/settings" target="_blank" rel="noopener">亚马逊</a> 网站登录<br>注意：由于之前使用的亚马逊账号可能是 amazon.cn 亚马逊中国，亚马逊中国网站和插件打开的 amazon.com 账号不互通。需要在 amazon.com 重新注册账号。如果之前就是使用的 amazon.com 直接登录就行。</p></li><li><p>在 Kindle 中登录在步骤 2 中的 amazon.com 的账号，已经登录了 amazon.cn 的账号可以先在 Kindle 中注销再登录 amazon.com 账号</p></li><li><p>回到 <a href="https://www.amazon.com/sendtokindle/settings" target="_blank" rel="noopener">amazon.com</a> 选择 Kindle 设备</p></li><li><p>在 Chrome 中打开网页，点击「Send to Kindle for Chrome」插件，可以预览也可以直接发送。</p></li></ol><p>如果遇到这种情况发送失败<br><img src="/img/kindle/network-error.png" alt="network-error"><br>需要把 Chrome 设置成英文</p><p>Chrome for Mac OS 设置英文方法，在终端执行下面的命令，执行完后关闭 Chrome 重新打开。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 中文 =&gt; 英文</span></span><br><span class="line">defaults write com.google.Chrome AppleLanguages <span class="string">'(en-US)'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 英文 =&gt; 中文</span></span><br><span class="line">defaults write com.google.Chrome AppleLanguages <span class="string">'(zh-CN)'</span></span><br></pre></td></tr></table></figure><p>之后再点击 Send to Kindle 就可以了，也没有乱码的情况。</p><p>总结</p><ol><li>amazon 账号不互动需要注意 .cn 和 .com 的两个账号体系</li><li>发送失败切换 Chrome 为英文</li></ol><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/102845304" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/102845304</a></li><li><a href="https://tongjunsz.gitee.io/2020/09/04/Mac-OS-X-%E4%B8%8B%E4%BF%AE%E6%94%B9-Google-Chrome-%E6%98%BE%E7%A4%BA%E8%AF%AD%E8%A8%80%E7%9A%84%E6%96%B9%E6%B3%95/" target="_blank" rel="noopener">https://tongjunsz.gitee.io/2020/09/04/Mac-OS-X-%E4%B8%8B%E4%BF%AE%E6%94%B9-Google-Chrome-%E6%98%BE%E7%A4%BA%E8%AF%AD%E8%A8%80%E7%9A%84%E6%96%B9%E6%B3%95/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近翻出了尘封许久的 Kindle 擦了擦灰，想起来一些偶尔在网络上看到的长篇文章推送到 Kindle 看也不错。&lt;br&gt;因为之前使用过，「亚马逊 Kindle 服务号」发送链接推送 Kindle，便发了个知乎的链接，在 Kindle 上打开乱码了。&lt;br&gt;在 Kindle
      
    
    </summary>
    
    
      <category term="Kindle" scheme="https://www.chengjingchao.com/categories/Kindle/"/>
    
    
      <category term="阅读" scheme="https://www.chengjingchao.com/tags/%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>快捷切换 Windows 代理开关</title>
    <link href="https://www.chengjingchao.com/2021/09/07/%E5%BF%AB%E6%8D%B7%E5%88%87%E6%8D%A2-Windows-%E4%BB%A3%E7%90%86%E5%BC%80%E5%85%B3/"/>
    <id>https://www.chengjingchao.com/2021/09/07/%E5%BF%AB%E6%8D%B7%E5%88%87%E6%8D%A2-Windows-%E4%BB%A3%E7%90%86%E5%BC%80%E5%85%B3/</id>
    <published>2021-09-07T15:25:26.000Z</published>
    <updated>2021-09-07T15:36:38.437Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近给公司的 Window 电脑配置了代理<del>（为了科学上网）</del>。全局的系统代理会导致有些软件不能正常使用。就需要频繁的切换代理开关。步骤如下</p><p><code>设置 =&gt; 网络和 Internet =&gt; 代理 =&gt; 开/关</code></p><p><img src="/img/proxy/switch.png" alt="running"></p><p>有点太过繁琐，搜了下解决方法</p><h2 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法 1"></a>解决方法 1</h2><p>先搜索到的<a href="https://www.computerworld.com/article/3218116/how-to-make-shortcuts-to-windows-10-settings-on-your-desktop.html" target="_blank" rel="noopener">这个</a>解决方案。<br>新建桌面快捷方式，</p><p><img src="/img/proxy/shortcut.png" alt="running"></p><p>下一步后起个名字完成即可。双击快捷方式即可直接打开代理设置。还是不太方便。</p><h2 id="解决方法-2"><a href="#解决方法-2" class="headerlink" title="解决方法 2"></a>解决方法 2</h2><p><a href="https://stackoverflow.com/questions/26708347/windows-desktop-widget-to-turn-proxy-on-and-off/26708451#26708451" target="_blank" rel="noopener">使用快捷键直接切换代理开关</a><br>其实有其他作者已经把这个解决方案的实现上传到了 <code>GitHub</code>，可以直接<a href="https://github.com/ElectricRCAircraftGuy/Windows_Proxy_Toggler" target="_blank" rel="noopener">下载</a>使用</p><ol><li>下载</li><li>放到 <code>C:\Users\YOUR_USERNAME</code> 目录下</li><li>点击目录下的 <code>toggle_proxy_on_off.vbs</code> 会直接创建桌面快捷方式</li></ol><p>注意事项</p><ol><li>下载的文件目录名称是否为 <code>Windows_Proxy_Toggler</code></li><li>放在当前用户目录下</li></ol><p>这时可以点击桌面快捷方式直接切换代理开关</p><p>更进一步为快捷方式绑定快捷键（<code>右键桌面快捷方式 =&gt; 属性</code>）<br><img src="/img/proxy/key.png" alt="running"></p><p>这时会发现按下快捷键后会有 <code>3s</code> 左右的延迟，再次使用万能的 <code>Google</code>，将<code>设置 =&gt; 后台应用 =&gt; 设置</code> 关掉即可。</p><p><img src="/img/proxy/setting.png" alt="running"></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://blog.csdn.net/qq_44275286/article/details/103988806" target="_blank" rel="noopener">https://blog.csdn.net/qq_44275286/article/details/103988806</a></li><li><a href="https://github.com/ElectricRCAircraftGuy/Windows_Proxy_Toggler" target="_blank" rel="noopener">https://github.com/ElectricRCAircraftGuy/Windows_Proxy_Toggler</a></li><li><a href="https://itectec.com/superuser/slow-windows-desktop-keyboard-shortcuts/" target="_blank" rel="noopener">https://itectec.com/superuser/slow-windows-desktop-keyboard-shortcuts/</a></li><li><a href="https://stackoverflow.com/questions/26708347/windows-desktop-widget-to-turn-proxy-on-and-off/26708451#26708451" target="_blank" rel="noopener">https://stackoverflow.com/questions/26708347/windows-desktop-widget-to-turn-proxy-on-and-off/26708451#26708451</a></li><li><a href="https://www.computerworld.com/article/3218116/how-to-make-shortcuts-to-windows-10-settings-on-your-desktop.html" target="_blank" rel="noopener">https://www.computerworld.com/article/3218116/how-to-make-shortcuts-to-windows-10-settings-on-your-desktop.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;最近给公司的 Window 电脑配置了代理&lt;del&gt;（为了科学上网）&lt;/del&gt;。全局的系统代理会导致有些软件不能正常使用。就需要频繁的切换
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>JavaScript 知识点整理</title>
    <link href="https://www.chengjingchao.com/2021/05/09/JavaScript-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
    <id>https://www.chengjingchao.com/2021/05/09/JavaScript-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/</id>
    <published>2021-05-09T01:19:29.000Z</published>
    <updated>2021-09-25T07:18:46.273Z</updated>
    
    <content type="html"><![CDATA[<h1 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h1><blockquote><p>变量、函数、属性或函数参数的名称。</p></blockquote><h3 id="标识符规则"><a href="#标识符规则" class="headerlink" title="标识符规则"></a>标识符规则</h3><ol><li>首字符必须是 <strong>字母、下划线</strong> 或 <strong>$</strong></li><li>其他字符可以是 <strong>字母、下划线、$</strong> 或 <strong>数字</strong></li></ol><ul><li>区分大小写</li><li>关键字保留字不能作为标识符</li><li>标识符采用驼峰写法，第一个字母小写，剩下的每个单词的首字母大写</li></ul><hr><h1 id="严格模式-use-strict"><a href="#严格模式-use-strict" class="headerlink" title="严格模式 use strict"></a>严格模式 use strict</h1><blockquote><p>一种不同的 JS 解析和执行模型。</p></blockquote><ul><li>不规范的写法会被处理</li><li>不安全的会抛出错误</li></ul><p>整个 js 文件启用严格模式，在开头加上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span></span><br></pre></td></tr></table></figure><p>单独指定一个函数严格模式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><blockquote><p>变量是松散类型，可以保存任何类型的数据</p></blockquote><h2 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h2><ol><li><code>var</code></li><li><code>let</code></li><li><code>const</code></li></ol><blockquote><p>不初始化默认保存 undefined</p></blockquote><h3 id="var"><a href="#var" class="headerlink" title="var"></a>var</h3><ul><li>变量提升（把变量声明放到作用域的顶部，初始化操作留在原处执行）</li><li>可以重复声明（变量提升会合为一个声明）</li><li>函数作用域（成为包含它的函数的局部变量）</li><li>全局变量会成为 window 对象的属性（可能会覆盖全局属性）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量提升</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(age)</span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">26</span></span><br><span class="line">&#125;</span><br><span class="line">foo() <span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> age</span><br><span class="line">  <span class="built_in">console</span>.log(age)</span><br><span class="line">  age = <span class="number">26</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以重复声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">16</span></span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">26</span></span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">36</span></span><br><span class="line">  <span class="built_in">console</span>.log(age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() <span class="comment">// 36</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数作用域</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> message = <span class="string">'hi'</span></span><br><span class="line">&#125;</span><br><span class="line">test()</span><br><span class="line"><span class="built_in">console</span>.log(message) <span class="comment">// ReferenceError: message is not defined</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量会成为 window 对象的属性</span></span><br><span class="line"><span class="keyword">var</span> message = <span class="string">'hi'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.message) <span class="comment">// hi</span></span><br></pre></td></tr></table></figure><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><ul><li>块作用域（函数内部或 {} 之间的区域）</li><li>同一个作用域禁止重复声明（作用域中已经存在某个标识符，再使用 let 声明会报错）</li><li>临时死区（在声明变量之前使用）</li><li>全局作用域中声明的变量不会成为 window 对象的属性</li><li>for 循环中的行为不一样（每次迭代时都会创建新的绑定）</li></ul><blockquote><p>块作用域：只在当前代码块内有效，执行到代码块外会立即销毁。</p></blockquote><blockquote><p>临时死区（Temporal Dead Zone）：与 var 不同，let 和 const 不会发生变量提升，如果在声明前访问这些变量，即使是 type of 也会触发引用错误。JS 引擎发现变量声明时，要么提升至作用域顶部（var），要么将声明放到 TDZ 中（let、const）。访问 TDZ 中的变量会触发运行时错误。只有执行过变量声明语句后，变量才会从 TDZ 中移出，方可正常访问。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 块作用域</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">'jack'</span></span><br><span class="line">  <span class="built_in">console</span>.log(name) <span class="comment">// jack</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(name) <span class="comment">// jack</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> age = <span class="number">26</span></span><br><span class="line">  <span class="built_in">console</span>.log(age) <span class="comment">// 26</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(age) <span class="comment">// ReferenceError: age is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能重复声明</span></span><br><span class="line"><span class="keyword">var</span> age</span><br><span class="line"><span class="keyword">let</span> age <span class="comment">// SyntaxError: Identifier 'age' has already been declared</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 暂时性死区</span></span><br><span class="line"><span class="built_in">console</span>.log(age)</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">26</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for 循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(i)</span><br><span class="line"></span><br><span class="line">循环里的每次迭代同时共享变量 i ，循环内部创建的函数全都保留了对相同变量的引用。</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> 循环中勇 <span class="keyword">let</span> 声明迭代变量时，JS 引擎在后台会为每一个迭代循环声明一个新的迭代变量。每个 setTimeout 引用的都是不同的变量实例。</span><br><span class="line">每次迭代循环都会创建一个新变量，并以之前迭代中同名变量的值将其初始化。</span><br></pre></td></tr></table></figure><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>const 基本与 let 相同。区别如下</p><ul><li>声明时必须初始化（赋值）</li><li>不能修改变量引用（可以修改对象内部属性）</li><li>在 for-in 或 for-of 循环中使用时与 let 一致</li></ul><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ol><li>不使用 var</li><li>const 优先 let 次之（知道未来会修改变量时，再使用let。）</li></ol><hr><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>ssb nnu o</p><ol><li>String</li><li>Symbol</li><li>Boolean</li><li>Null</li><li>Number</li><li>Undefined</li><li>Object</li></ol><h2 id="type-of"><a href="#type-of" class="headerlink" title="type of"></a>type of</h2><p>typoe of 会返回下列字符串</p><ol><li>string</li><li>symbol</li><li>boolean</li><li>number</li><li>function</li><li>undefined</li><li>object 对象 或 null</li></ol><h2 id="Undefined"><a href="#Undefined" class="headerlink" title="Undefined"></a>Undefined</h2><p>var 或 let 声明了但没有初始化就相当于给变量赋值 undefined<br>不要显式初始化 undefined<br>typeof 未声明和未初始化的变量都返回 undefined<br>建议声明变量的同时进行初始化，这样当 type of 返回 undefined 时，就只当是变量尚未声明。</p><p>undefined 的意义就是区分空对象指针 null 和未初始化变量的区别。</p><h2 id="Null"><a href="#Null" class="headerlink" title="Null"></a>Null</h2><p>空对象指针<br>声明要保存对象的变量时，建议使用 null 初始化，这样检测是不是 null 就可以知道是否后来被重新赋值了</p><p>undefined 由 null 派生而来 null == undefined // true</p><h2 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h2><p>true false</p><p>Boolean() 可以转换任意数据类型，返回一个 boolean 值 if()<br>转换为 false 的值<br>false、’’、0、NaN、null、undefined</p><h2 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h2><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><ol><li>Number()</li><li>parseInt()</li><li>parseFloat() 只解析十进制值</li></ol><p>Number() 是转型函数，可用于任何数据类型<br>后两个函数主要用于将字符串转换为数值。</p><p>Number()</p><ul><li>布尔值 =&gt; 1, 0</li><li>数值直接返回</li><li>null =&gt; 0</li><li>undefined =&gt; NaN</li><li>‘’ =&gt; 0</li><li>有效数字字符串返回数字，其他为 NaN</li></ul><p>parseInt(, 10)</p><ul><li>‘’ =&gt; NaN</li></ul><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>字符串是不可变的，一旦创建值就不能修改。<br>要修改某个变量中的字符串值，必须先销毁原始字符串，然后将包含新值的另一个字符串保存到该变量。</p><h3 id="转换为字符串"><a href="#转换为字符串" class="headerlink" title="转换为字符串"></a>转换为字符串</h3><p>age.toString()</p><h1 id="基本引用类型"><a href="#基本引用类型" class="headerlink" title="基本引用类型"></a>基本引用类型</h1><p>构造函数就是用来创造新对象的函数<br>new 其实就是创建一个对象<br>new Date()</p><h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><p>UTC 时间 保存 1970-01-01 至今所经过的毫秒数</p><h2 id="RegExp"><a href="#RegExp" class="headerlink" title="RegExp"></a>RegExp</h2><h2 id="原始值包装类型"><a href="#原始值包装类型" class="headerlink" title="原始值包装类型"></a>原始值包装类型</h2><ul><li>Boolean</li><li>Number</li><li>String</li></ul><p>包装对象</p><ol><li>JavaScript 中一切皆对象</li><li>方便原始类型的值调用某些方法或属性</li></ol><p>只有引用类型（对象）才有属性和方法，原始类型是没有属性和方法的。</p><ol><li><p>在JavaScript中，“一切皆对象”，包括三种原始类型的值(数值、字符串、布尔值)，在一定条件下，也会自动转为对象，也就是原始类型的“包装对象”。</p></li><li><p>包装对象是特殊的引用类型。每当读取数字、字符串和布尔值的属性或方法时，创建的临时对象称做包装对象.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 new 调用 返回的是个对象 type object</span></span><br><span class="line"><span class="keyword">const</span> n = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>)</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'123'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接调用 将任意类型的值，转为原始类型的值。</span></span><br><span class="line"><span class="keyword">const</span> n = <span class="built_in">Number</span>(<span class="number">123</span>)</span><br><span class="line"><span class="keyword">const</span> b = <span class="built_in">Boolean</span>(<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">const</span> s = <span class="built_in">String</span>(<span class="string">'123'</span>)</span><br></pre></td></tr></table></figure></li></ol><p>包装对象销毁</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">'hello'</span>;</span><br><span class="line">str.name = <span class="string">'jack'</span>; <span class="comment">// 创建临时包装对象，这行代码执行完包装对象就会销毁</span></span><br><span class="line"><span class="built_in">console</span>.log(str.name) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://segmentfault.com/a/1190000015107989" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015107989</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;标识符&quot;&gt;&lt;a href=&quot;#标识符&quot; class=&quot;headerlink&quot; title=&quot;标识符&quot;&gt;&lt;/a&gt;标识符&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;变量、函数、属性或函数参数的名称。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;标识符规则&quot;&gt;&lt;a
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>你不知道的 JavaScript（上）</title>
    <link href="https://www.chengjingchao.com/2021/03/14/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84-JavaScript-%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>https://www.chengjingchao.com/2021/03/14/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84-JavaScript-%EF%BC%88%E4%B8%8A%EF%BC%89/</id>
    <published>2021-03-14T00:35:35.000Z</published>
    <updated>2021-03-14T13:52:10.685Z</updated>
    
    <content type="html"><![CDATA[<p>这本书主要有两部分内容</p><ol><li>作用域和闭包</li><li>this 和原型对象</li></ol><p>之前看过一部分，这次再看一遍顺便整理笔记。</p><h1 id="作用域是什么"><a href="#作用域是什么" class="headerlink" title="作用域是什么"></a>作用域是什么</h1><p>作用域是一套规则，用来管理引擎如何查找变量。</p><p>引擎查找变量的两种方式</p><ol><li>LHS 查询 (查找变量的引用，赋值操作的目标)</li><li>RHS 查询（查找变量的值）</li></ol><p>作用域的分类</p><ol><li>全局作用域</li><li>函数作用域</li><li>块作用域</li></ol><h2 id="作用域嵌套"><a href="#作用域嵌套" class="headerlink" title="作用域嵌套"></a>作用域嵌套</h2><p>JavaScript 是一门编译语言。但与传统的编译语言不通，它不是提前编译的，编译结果也不能在系统中到处移植。</p><p>传统的解释和编译<br>解释执行：每次运行前解释器解释执行。<br>编译执行：编译成机器语言保存后，一次编译多次运行。</p><p>传统的编译步骤</p><ol><li>分词/词法分析  将代码分解成词法单元 var a = 2; =&gt; var、a、=、2、;</li><li>解析/语法分析  转换成由元素逐级嵌套所组成的代表程序语法结构的树。抽象语法书（AST）</li><li>代码生成  将 AST 转换为可执行代码</li></ol><p>JavaScript 在执行前都要进行编译（通常就在执行前）</p><p>作用域<br>作用域嵌套<br>词法作用域<br>函数作用域<br>块作用域</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这本书主要有两部分内容&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;作用域和闭包&lt;/li&gt;
&lt;li&gt;this 和原型对象&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;之前看过一部分，这次再看一遍顺便整理笔记。&lt;/p&gt;
&lt;h1 id=&quot;作用域是什么&quot;&gt;&lt;a href=&quot;#作用域是什么&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="阅读笔记" scheme="https://www.chengjingchao.com/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="https://www.chengjingchao.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>写给大家看的设计书</title>
    <link href="https://www.chengjingchao.com/2021/03/08/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E5%86%99%E7%BB%99%E5%A4%A7%E5%AE%B6%E7%9C%8B%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B9%A6/"/>
    <id>https://www.chengjingchao.com/2021/03/08/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E5%86%99%E7%BB%99%E5%A4%A7%E5%AE%B6%E7%9C%8B%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B9%A6/</id>
    <published>2021-03-08T12:46:46.000Z</published>
    <updated>2021-03-14T00:38:35.447Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><h2 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h2><blockquote><p>一旦能够说出什么东西的名字，就会很容易注意到它。</p></blockquote><p>4 大基本设计原则</p><ul><li>对比 —— 突出重点避免页面上元素太过相似（可以是字体、颜色、大小、线宽、形状、空间等方面的对比）</li><li>重复 —— 重复颜色、形状、材质、空间关系、线宽、字体、大小和图片等。增加条理性和统一性。</li><li>对齐 —— 不能随意安放。应当与页面上的另一个元素有某种视觉联系。清晰、精巧且清爽的外观。</li><li>亲密性 —— 彼此相关的项应当靠近，归组在一起。组织信息，减少混乱，为读者提供清晰的结构。</li></ul><h2 id="2-亲密性"><a href="#2-亲密性" class="headerlink" title="2. 亲密性"></a>2. 亲密性</h2><h2 id="3-对齐"><a href="#3-对齐" class="headerlink" title="3. 对齐"></a>3. 对齐</h2><h2 id="4-重复"><a href="#4-重复" class="headerlink" title="4. 重复"></a>4. 重复</h2><h2 id="5-对比"><a href="#5-对比" class="headerlink" title="5. 对比"></a>5. 对比</h2><h2 id="6-4-大基本原则复习"><a href="#6-4-大基本原则复习" class="headerlink" title="6. 4 大基本原则复习"></a>6. 4 大基本原则复习</h2><h2 id="7-颜色运用"><a href="#7-颜色运用" class="headerlink" title="7. 颜色运用"></a>7. 颜色运用</h2><p>色轮的基础是红、黄和蓝 3 种颜色。被称为三原色（无法创建的颜色，其他颜色可以通过混合颜色得到但是没有办法通过混合其他颜色来得到纯黄、纯红或纯蓝色）<br>三原色色轮</p><p>将色轮上相邻的颜色等量混合，就会得到三间色<br>黄 + 蓝 = 绿<br>黄 + 红 = 橙<br>蓝 + 红 = 绿</p><p>把上面色轮空白两边的颜色等量混合就会得到第三色</p><p>色轮的色彩应用</p><ul><li>互补</li><li>三色组</li><li>分裂互补三色组</li><li>类似色</li></ul><p>色轮上相对的颜色为互补色。一种作为主色，另一种用于强调</p><p>彼此等距的三种颜色通常会形成一个让人愉悦的三色组。</p><p>红黄蓝就是一种三色组也称为基色三色组。儿童产品通常都采用这种组合</p><p>另一种形式的三色组称为分裂互补三色组。从色轮一边选择一种颜色，再在色轮上找出它对面互补色两侧的颜色。</p><p>类似色组合由色轮上彼此相邻的颜色组成。不论是组合两种颜色还是三种颜色，他们都有相同的基础色，这就形成了一个协调的组合。用不同的亮色和暗色组合一组类似色</p><ul><li>色调就是纯色</li><li>向色调增加黑色就构成一个暗色</li><li>向色调增加白色就构成一个亮色</li></ul><p>单色<br>单色组合由一种色调（纯色）及其相应的多种亮色和暗色组成。</p><p>暖色与冷色<br>颜色往往要么是暖色（说明其中包含红色或黄色），要么是冷色（说明其中包含蓝色）。<br>冷色趋于做背景色，而暖色是趋进型。</p><h3 id="如何取舍"><a href="#如何取舍" class="headerlink" title="如何取舍"></a>如何取舍</h3><ol><li>项目是否有季节性？</li><li>官方色？</li><li>是否包含图片</li></ol><h2 id="8-更多提示与技巧"><a href="#8-更多提示与技巧" class="headerlink" title="8. 更多提示与技巧"></a>8. 更多提示与技巧</h2><h1 id="字体设计"><a href="#字体设计" class="headerlink" title="字体设计"></a>字体设计</h1><h2 id="9-字体的基本规则"><a href="#9-字体的基本规则" class="headerlink" title="9. 字体的基本规则"></a>9. 字体的基本规则</h2><h2 id="10-字体与人生"><a href="#10-字体与人生" class="headerlink" title="10. 字体与人生"></a>10. 字体与人生</h2><h2 id="11-字体类别"><a href="#11-字体类别" class="headerlink" title="11. 字体类别"></a>11. 字体类别</h2><ul><li>OldStyle (旧式体)</li><li>Modern (现代体)</li><li>Slab serif (粗衬线体)</li><li>Sans serif (无衬线体)</li><li>Script (手写体)</li><li>Descorative (花体)</li></ul><h2 id="12-字体对比"><a href="#12-字体对比" class="headerlink" title="12. 字体对比"></a>12. 字体对比</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;设计原则&quot;&gt;&lt;a href=&quot;#设计原则&quot; class=&quot;headerlink&quot; title=&quot;设计原则&quot;&gt;&lt;/a&gt;设计原则&lt;/h1&gt;&lt;h2 id=&quot;1-引言&quot;&gt;&lt;a href=&quot;#1-引言&quot; class=&quot;headerlink&quot; title=&quot;1. 引言&quot;&gt;&lt;/
      
    
    </summary>
    
    
      <category term="阅读笔记" scheme="https://www.chengjingchao.com/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="设计" scheme="https://www.chengjingchao.com/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>GitHub 配置 SSH 连接</title>
    <link href="https://www.chengjingchao.com/2021/01/20/GitHub-%E9%85%8D%E7%BD%AE-SSH-%E8%BF%9E%E6%8E%A5/"/>
    <id>https://www.chengjingchao.com/2021/01/20/GitHub-%E9%85%8D%E7%BD%AE-SSH-%E8%BF%9E%E6%8E%A5/</id>
    <published>2021-01-20T14:05:37.000Z</published>
    <updated>2021-01-20T14:21:43.433Z</updated>
    
    <content type="html"><![CDATA[<h1 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h1><p>Git 可以使用的 4 种协议</p><ol><li>HTTP 协议</li><li>SSH</li><li>本地协议</li><li>Git 协议</li></ol><p>普遍使用的则是 HTTP 和 SSH，说一说这两种方式的优缺点。</p><p><img src="/img/github-ssh/http_ssh.png" alt=""></p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>优点</p><ul><li>相同 URL（同一个 URL，仓库地址、clone 和 push 都是相同地址 例如: GitHub 上的仓库）</li><li>使用简单（只在需要授权时提示输入用户名/密码）</li><li>既可以设置无授权匿名服务，也可以传输时授权和加密</li></ul><p>缺点</p><ul><li>架设 HTTP/S 协议会比 SSH 麻烦一些</li><li>授权比较麻烦（需要频繁输入账号密码，当然 Git 也提供有缓存功能）</li></ul><h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><p>优点</p><ul><li>普遍（大多数服务器已支持 SSH 访问，即使没有也很容易架设）</li><li>安全（数据传输要经过授权和加密）</li><li>高效（传输尽量压缩数据）</li></ul><p>缺点</p><ul><li>不能匿名访问，不利于开源项目（即便只要读取数据，也要有通过 SSH 访问主机的权限）</li></ul><h1 id="使用-SSH"><a href="#使用-SSH" class="headerlink" title="使用 SSH"></a>使用 SSH</h1><p>SSH 密钥可以让用户无需输入密码即可登录到 SSH 服务器中。SSH 密钥总是成对出现（公钥和私钥）</p><p>使用流程</p><ol><li>生成密钥对</li><li>将生成的公钥添加到服务器</li><li>测试连接</li></ol><p>SSH 连接的时候，远程服务器向用户发送一段随机字符串，用户使用对应的私钥加密后，再发送到远程主机。<br>远程主机使用公钥进行解密，如果成功证明用户是可信的。这一过程不需要用户手动操作。</p><h2 id="生成密钥对"><a href="#生成密钥对" class="headerlink" title="生成密钥对"></a>生成密钥对</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen</span><br></pre></td></tr></table></figure><p>选项</p><ul><li>-t 可选 指定加密算法，默认 RSA</li><li>-b 可选 生成密钥长度</li><li>-C 可选 添加密钥对的说明（你可以随便输入内容）</li><li>-f 可选 指定生成私钥文件名，不使用 -f 会在创建过程中会提示用户输入</li><li>-P 可选 指定 passphrase 使用私钥时的密码 passphrase 至少 5 个字符</li><li>-p 可选 修改 passphrase</li></ul><p>私钥默认名称为 id_ + 算法名称<br>私钥对应的公钥名称为 私钥文件名 + .pub</p><p><code>ssh-keygen</code> 不添加任何选项生成过程中<br>第一次提示用户输入是保存密钥的文件名，直接回车使用默认值。<br>第二次提示用户输入 passphrase ，passphrase 是一个密码（使用私钥时的密码，使用后会在每次 pull、push 等操作中验证 passphrase）不使用可直接回车。<br>第三次提示用书再次输入 passphrase。<br>完成后 <code>~/.ssh</code> 目录下会多出两个文件 <code>id_rsa</code>、<code>id_rsa.pub</code>。</p><h2 id="将生成的公钥添加到服务器"><a href="#将生成的公钥添加到服务器" class="headerlink" title="将生成的公钥添加到服务器"></a>将生成的公钥添加到服务器</h2><p>GitHub: <code>Settings</code> &gt; <code>SSH and GPG keys</code> &gt; <code>New SSH key</code><br>将上一步生成的 <code>.pub</code> 的公钥内容复制到 Key 中，Title 随便填，添加即可。</p><h2 id="测试连接"><a href="#测试连接" class="headerlink" title="测试连接"></a>测试连接</h2><p>公钥添加到 GitHub，可以使用 SSH 测试 GItHub 连接，没有问题会输出欢迎语句。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br><span class="line">Hi jingchaocheng! You<span class="string">'ve successfully authenticated, but GitHub does not provide shell access.</span></span><br></pre></td></tr></table></figure><p>如果出现了下面的问题 （<a href="https://docs.github.com/cn/github/authenticating-to-github/using-ssh-over-the-https-port" target="_blank" rel="noopener">了解更多</a>）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br><span class="line">ssh: connect to host github.com port 22: Connection timed out</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@github.com:jingchaocheng/git.git</span><br><span class="line">Cloning into <span class="string">'git'</span>...</span><br><span class="line">ssh: connect to host github.com port 22: Connection timed out</span><br><span class="line">fatal: Could not <span class="built_in">read</span> from remote repository.</span><br><span class="line"></span><br><span class="line">Please make sure you have the correct access rights</span><br><span class="line">and the repository exists.</span><br></pre></td></tr></table></figure><p>解决方法<br>在 <code>~/.ssh/</code> 目录下 <code>config</code>（如果没有新建一个）文件中添加下面内容后，再次测试链接。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">Hostname ssh.github.com</span><br><span class="line">Port 443</span><br></pre></td></tr></table></figure><h1 id="同一设备多个-Git-托管服务"><a href="#同一设备多个-Git-托管服务" class="headerlink" title="同一设备多个 Git 托管服务"></a>同一设备多个 Git 托管服务</h1><p>场景：公司内工作开发使用 GitLab，自己瞎折腾用的 GitHub、Gitee（即便每个平台注册的邮箱号不同也可以）。</p><p>使用方法：将之前生成的公钥添加到各个 Git 托管服务中即可。</p><p>需注意各个平台上的用户名和邮箱是否和本地的 git config 中的内容一致，如需修改参考下面的配置用户信息。</p><h1 id="同一设备两个-GitHub-账号"><a href="#同一设备两个-GitHub-账号" class="headerlink" title="同一设备两个 GitHub 账号"></a>同一设备两个 GitHub 账号</h1><p>场景：有两个不同的 GitHub 账号，想在同一台电脑上使用。（同理可解决 两个 GitLab 账号、两个 Gitee 账号问题在同一设备使用的问题）。</p><p>公钥在同一个托管平台上具有唯一性，所以同一平台的多个账号不能使用同一公钥，这种情况需要生成多个密钥使用，每个账号对应一个密钥对。</p><p>在同一个平台上多个账号添加同一个公钥的错误提示<br><img src="/img/github-ssh/github.png" alt=""><br>GitHub<br><img src="/img/github-ssh/git-tree.png" alt=""><br>Gitee</p><p>再次生成一对密钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -f 996</span><br></pre></td></tr></table></figure><p>这个时候 ssh 目录下应该有两对密钥 4 个文件<br>新建 config 文件，添加以下内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 id_rsa 密钥的</span></span><br><span class="line">Host github.com</span><br><span class="line">Hostname ssh.github.com</span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 996 密钥的</span></span><br><span class="line">Host 996</span><br><span class="line">Hostname sss.github.com</span><br><span class="line">IdentityFile ~/.ssh/996</span><br></pre></td></tr></table></figure><p>每个配置区段使用 <code>Host</code> 来区分， <code>IdentityFile</code> 指定<strong>私钥</strong>文件路径</p><p>将两个公钥的内容分别添加到两个账号的 <code>SSH keys</code> 中</p><p>使用 <code>config</code> 文件中第一个 <code>Host</code> 配置时和之前一样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:jingchaocheng/git.git</span><br></pre></td></tr></table></figure><p>使用 <code>config</code> 文件中使用第二个 <code>Host</code> 配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@996:996-vip/git.git</span><br><span class="line"><span class="comment"># 并非原来的 git@github.com:996-vip/git.git</span></span><br><span class="line"><span class="comment"># 需要将 github.com 修改成 第二个 host 配置的 996（可以自定义这个名字，一致就行）</span></span><br><span class="line"><span class="comment"># 996-vip 为 GitHub 用户名</span></span><br></pre></td></tr></table></figure><p><img src="/img/github-ssh/git_clone.png" alt=""></p><p>这样就完成了在同一设备同时使用两个 GitHub 账号的设置，记得配置 clone 仓库的用户信息。两个账号的用户信息必定不相同。</p><h1 id="配置用户信息"><a href="#配置用户信息" class="headerlink" title="配置用户信息"></a>配置用户信息</h1><p>Git 配置文件存储在三个不同位置，有相同配置时下级覆盖上级。</p><p><img src="/img/github-ssh/git_config.png" alt=""></p><p>示例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前用户</span></span><br><span class="line">git config --global user.name <span class="string">"你的用户名"</span></span><br><span class="line">git config --global user.email <span class="string">"你的邮箱"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前仓库</span></span><br><span class="line">git config --<span class="built_in">local</span> user.name <span class="string">"你的用户名"</span></span><br><span class="line">git config --<span class="built_in">local</span> user.email <span class="string">"你的邮箱"</span></span><br></pre></td></tr></table></figure><p>每一次 Git 的提交都会使用这些信息，并写入到每一次提交中。提交记录中的 Author 就是取的配置文件中的 <code>user.name</code> 和 <code>uesr.email</code>。所以都修改成当前仓库的 git config 的用户名和邮箱与目标托管平台中的用户名和邮箱一致即可。</p><h1 id="参考链接-🔗"><a href="#参考链接-🔗" class="headerlink" title="参考链接 🔗"></a>参考链接 🔗</h1><ul><li><a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">https://git-scm.com/book/zh/v2</a></li><li><a href="https://www.cnblogs.com/ayseeing/p/3572582.html" target="_blank" rel="noopener">https://www.cnblogs.com/ayseeing/p/3572582.html</a></li><li><a href="https://www.cnblogs.com/ayseeing/p/4445194.html" target="_blank" rel="noopener">https://www.cnblogs.com/ayseeing/p/4445194.html</a></li><li><a href="https://daemon369.github.io/ssh/2015/03/08/generating-ssh-keys" target="_blank" rel="noopener">https://daemon369.github.io/ssh/2015/03/08/generating-ssh-keys</a></li><li><a href="https://docs.github.com/cn/github/authenticating-to-github/using-ssh-over-the-https-port" target="_blank" rel="noopener">https://docs.github.com/cn/github/authenticating-to-github/using-ssh-over-the-https-port</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;协议&quot;&gt;&lt;a href=&quot;#协议&quot; class=&quot;headerlink&quot; title=&quot;协议&quot;&gt;&lt;/a&gt;协议&lt;/h1&gt;&lt;p&gt;Git 可以使用的 4 种协议&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;HTTP 协议&lt;/li&gt;
&lt;li&gt;SSH&lt;/li&gt;
&lt;li&gt;本地协议&lt;/li&gt;
&lt;
      
    
    </summary>
    
    
      <category term="Git" scheme="https://www.chengjingchao.com/categories/Git/"/>
    
    
      <category term="Git" scheme="https://www.chengjingchao.com/tags/Git/"/>
    
      <category term="GitHub" scheme="https://www.chengjingchao.com/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>2020 年终总结</title>
    <link href="https://www.chengjingchao.com/2020/12/31/2020-%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>https://www.chengjingchao.com/2020/12/31/2020-%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</id>
    <published>2020-12-31T13:05:44.000Z</published>
    <updated>2020-12-31T15:39:20.193Z</updated>
    
    <content type="html"><![CDATA[<p>2020 年结束了，说起年终总结，每次打开别人的博客可能我最感兴趣的就是年终总结的文章了。可以看到他/她人这一年是如何度过的，也能了解到很多乐趣。可惜的是我自己从来却没写过。今年终于开始写博客了，便也想记录下自己这一年的一些生活琐碎。若干年后自己在看这些文字的时候，也许会很有意思。</p><p>今年最避不开的话题就是疫情了。1 月份的时候偶尔看到武汉华南海鲜市场的新闻，当时并没有太留意。1 月 19 过年回家中途路过武汉，在武汉火车站看到稀稀疏疏的几个人戴着口罩。20 日上午到家一切都还很平常，到 23 日武汉封城疫情大面积爆发。在家里度过了一个最特殊的春节。也是我自从出来参加工作后第一次这么长时间和家人待在一起。3 月 24 乘点对点大巴从襄阳回到深圳。</p><div style="display: flex; align-items: center;justify-content: space-between;">  <img src="/img/2020/2020-station.jpeg" width = "300"/>  <img src="/img/2020/2020-bus.jpeg" width = "300"/></div><h1 id="New-year’s-Resolution"><a href="#New-year’s-Resolution" class="headerlink" title="New year’s Resolution"></a>New year’s Resolution</h1><p>年初一次英语作业立的 Flag，算完成了一半吧。</p><ul><li><input disabled="" type="checkbox"> I will hard work.</li><li><input disabled="" type="checkbox"> I will read 10 books.</li><li><input checked="" disabled="" type="checkbox"> I will run at least once a week.s</li><li><input checked="" disabled="" type="checkbox"> I will learn Engliish and freestyle.</li><li><input checked="" disabled="" type="checkbox"> I will go to the gym at least three times a week.</li></ul><h1 id="业余爱好"><a href="#业余爱好" class="headerlink" title="业余爱好"></a>业余爱好</h1><ul><li>健身 - 从 3 月份来深圳后到 8、9 月份还有经常去。随着后面年卡快到期就没去了。只不过一日三餐都在外面吃，很难针对健身的需求来摄入食物。也许等以后自己做饭了还会重新启动。健身效果增重了快 20 斤吧。</li><li>游泳 - 今年的次数比去年少了一些，去年学会了蛙泳，自由泳今年有学不过至今还没有学会。</li><li>跑步 - 今年的跑步数据。<img src="/img/2020/2020-run.png" width = "300"/></li></ul><h1 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h1><p>这一年换了工作部门，比之前忙了不少，还算有所收获。<br>回想当初刚学 CSS 的时候，学到 placeholder（之前都用 js 来实现相同效果）、border-radius 等一些很简单的属性的时候都能开心不已。或许参加工作后丢失了一些东西。希望新的一年自己也可以做出一些小玩意儿，给自己一些成就感，自己擅长的领域能有所沉淀。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>今年的年终总结没什么内容可写。记录下此刻的感受。期待新的一年丰富自己。</p><p>希望新的一年家人身体健康！</p><p>2021 年的目标</p><ul><li><input disabled="" type="checkbox"> 学会自由泳</li><li><input disabled="" type="checkbox"> 继续坚持跑步，争取能跑一场马拉松（WuHan）</li><li><input disabled="" type="checkbox"> 每个月最少看一本技术相关的书</li><li><input disabled="" type="checkbox"> 学习完 ENGLISH GRAMMAR IN USE 两本书</li><li><input disabled="" type="checkbox"> 换<del><strong>**</strong></del></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2020 年结束了，说起年终总结，每次打开别人的博客可能我最感兴趣的就是年终总结的文章了。可以看到他/她人这一年是如何度过的，也能了解到很多乐趣。可惜的是我自己从来却没写过。今年终于开始写博客了，便也想记录下自己这一年的一些生活琐碎。若干年后自己在看这些文字的时候，也许会很
      
    
    </summary>
    
    
    
      <category term="生活" scheme="https://www.chengjingchao.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="总结" scheme="https://www.chengjingchao.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Vue 组件选项和组合式 Api 对比</title>
    <link href="https://www.chengjingchao.com/2020/12/20/Vue-%E7%BB%84%E4%BB%B6%E9%80%89%E9%A1%B9%E5%92%8C%E7%BB%84%E5%90%88%E5%BC%8F-Api-%E5%AF%B9%E6%AF%94/"/>
    <id>https://www.chengjingchao.com/2020/12/20/Vue-%E7%BB%84%E4%BB%B6%E9%80%89%E9%A1%B9%E5%92%8C%E7%BB%84%E5%90%88%E5%BC%8F-Api-%E5%AF%B9%E6%AF%94/</id>
    <published>2020-12-20T06:56:02.000Z</published>
    <updated>2020-12-31T15:46:13.776Z</updated>
    
    <content type="html"><![CDATA[<p>整理 Vue 3.0 组件选项和 Composition API 的对比</p><h1 id="Composition-API-的优点"><a href="#Composition-API-的优点" class="headerlink" title="Composition API 的优点"></a>Composition API 的优点</h1><blockquote><ul><li>更好的逻辑复用与代码组织</li><li>更好的类型推导</li></ul></blockquote><h1 id="响应式数据"><a href="#响应式数据" class="headerlink" title="响应式数据"></a>响应式数据</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * before</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">data () &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    age: <span class="number">10</span>,</span><br><span class="line">    name: <span class="string">'Jack'</span>,</span><br><span class="line">    color: [<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'yellow'</span>],</span><br><span class="line">    grade: &#123;</span><br><span class="line">      art: <span class="number">90</span>,</span><br><span class="line">      math: <span class="number">90</span>,</span><br><span class="line">      english: <span class="number">90</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改</span></span><br><span class="line"><span class="keyword">this</span>.age = <span class="number">20</span></span><br><span class="line"><span class="keyword">this</span>.name = <span class="string">'Tom'</span></span><br><span class="line"><span class="comment">// vue2 中的修改 Object.defineProperty(grade, 'art', &#123; get() &#123;&#125;, set() &#123;&#125; &#125;) 需要提供具体的 key</span></span><br><span class="line"><span class="keyword">this</span>.$<span class="keyword">set</span>(this.color, 0, 'orange')</span><br><span class="line">this.$<span class="keyword">set</span>(this.grade, 'art', 100)</span><br><span class="line">// vue3 中的修改</span><br><span class="line">this.color[0] = 'orange'</span><br><span class="line">this.grade.art = 100</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * after</span><br><span class="line"> */</span><br><span class="line">setup () &#123;</span><br><span class="line">  <span class="keyword">const</span> age = ref(<span class="number">10</span>) <span class="comment">// new Proxy(&#123; value: 10 &#125;, &#123; get(target, key) &#123;&#125;, set(target, key, value) &#123;&#125; &#125;)</span></span><br><span class="line">  <span class="keyword">const</span> name = ref(<span class="string">'jack'</span>) <span class="comment">// new Proxy(&#123; value: 'jack' &#125;)</span></span><br><span class="line">  <span class="keyword">const</span> color = reactive([<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'yellow'</span>]) <span class="comment">// new Proxy(['red', 'blue', 'yellow'])</span></span><br><span class="line">  <span class="keyword">const</span> grade = reactive(&#123; <span class="attr">art</span>: <span class="number">90</span>, <span class="attr">math</span>: <span class="number">90</span>, <span class="attr">english</span>: <span class="number">90</span> &#125;) <span class="comment">// ne Proxy(&#123; art: 90, math: 90, english: 90 &#125;)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 修改</span></span><br><span class="line">  age.value = <span class="number">20</span></span><br><span class="line">  name.value = <span class="string">'Tom'</span></span><br><span class="line">  color[<span class="number">0</span>] = <span class="string">'orange'</span></span><br><span class="line">  grade.art = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    age,</span><br><span class="line">    name,</span><br><span class="line">    color,</span><br><span class="line">    grade</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="props"><a href="#props" class="headerlink" title="props"></a>props</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * before</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">props: [<span class="string">'name'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.name</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * after</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">props: [<span class="string">'name'</span>]</span><br><span class="line"></span><br><span class="line">setup (props) &#123;</span><br><span class="line">  props.name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="非-Prop-的-Attribute"><a href="#非-Prop-的-Attribute" class="headerlink" title="非 Prop 的 Attribute"></a>非 Prop 的 Attribute</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * before</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">this</span>.$attrs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * after</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">setup (props, &#123; attrs &#125;) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="生命周期函数"><a href="#生命周期函数" class="headerlink" title="生命周期函数"></a>生命周期函数</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * before</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">beforeCreate () &#123;</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">created () &#123;</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">beforeMount () &#123;</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">mounted () &#123;</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">beforeUpdate () &#123;</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">updated () &#123;</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">beforeUnmount () &#123;</span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">unmounted () &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * after</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> &#123; onBeforeMount, onMounted, onBeforeUpdate, onUpdated, onBeforeUpmount, onMounted &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line">setup () &#123;</span><br><span class="line">  onBeforeMount(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  onMounted(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  onBeforeUpdate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  onUpdated(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  onBeforeUpmount(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  onMounted(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="methods"><a href="#methods" class="headerlink" title="methods"></a>methods</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * before</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">methods: &#123;</span><br><span class="line">  changeName () &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * after</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">setup () &#123;</span><br><span class="line">  <span class="keyword">const</span> changeName = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    changeName</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="slots"><a href="#slots" class="headerlink" title="slots"></a>slots</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * before</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">this</span>.$slots</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * after</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">setup (props, &#123; slots &#125;) &#123;</span><br><span class="line">  slots.default()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="emit"><a href="#emit" class="headerlink" title="emit"></a>emit</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * before</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">this</span>.$emit(<span class="string">'change'</span>, <span class="string">'value'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * after</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">setup(props, &#123; emit &#125;) &#123;</span><br><span class="line">  emit(<span class="string">'change'</span>, <span class="string">'value'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="provide"><a href="#provide" class="headerlink" title="provide"></a>provide</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * before</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// parent</span></span><br><span class="line">provide: &#123;</span><br><span class="line">  user: <span class="string">'Jack'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// child</span></span><br><span class="line">inject: [<span class="string">'user'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * after</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// parent</span></span><br><span class="line">setup () &#123;</span><br><span class="line">  <span class="keyword">const</span> name = ref(<span class="string">'Jack'</span>)</span><br><span class="line">  provide(<span class="string">'name'</span>, readonly(name))</span><br><span class="line">  provide(<span class="string">'changeName'</span>, (value) =&gt; &#123;</span><br><span class="line">    name.value = value</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// child</span></span><br><span class="line">setup () &#123;</span><br><span class="line">  <span class="keyword">const</span> name = inject(<span class="string">'name'</span>)</span><br><span class="line">  <span class="keyword">const</span> changeName = injiect(<span class="string">'changeName'</span>)</span><br><span class="line">  changeName(<span class="string">'Tom'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * before</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">watch: &#123;</span><br><span class="line">  userName (newVal, oldVal) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * after</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">watch(nameObj, (oldVal, newVal) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">watch(<span class="function"><span class="params">()</span> =&gt;</span> nameObj.name, (oldVal, newVal) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">watch([<span class="function"><span class="params">()</span> =&gt;</span> nameObj.name, () =&gt; nameObj.englishName], ([newVal1, newVal2], [oldVal1, oldVal2]) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">watch(nameObj, () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;, &#123;</span><br><span class="line">  immediate: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * before</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">computed: &#123;</span><br><span class="line">  getCount () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.count</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * after</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">setup () &#123;</span><br><span class="line">  computed(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> count + <span class="number">5</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  computed(&#123;</span><br><span class="line">    <span class="keyword">get</span> () &#123;</span><br><span class="line">      <span class="keyword">return</span> count</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span> (value) &#123;</span><br><span class="line">      count.value = value + <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Dom-ref"><a href="#Dom-ref" class="headerlink" title="Dom ref"></a>Dom ref</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">"hello"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * before</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">this</span>.$refs.hello</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * after</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">setup () &#123;</span><br><span class="line">  <span class="keyword">const</span> hello = ref(<span class="literal">null</span>)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    hello</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * after</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> &#123; useStore &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line">setup () &#123;</span><br><span class="line">  <span class="keyword">const</span> store = useStore()</span><br><span class="line">  <span class="comment">// const name = store.state.name</span></span><br><span class="line">  <span class="keyword">const</span> &#123; name &#125; = toRefs(store.state)</span><br><span class="line">  store.dispatch(<span class="string">'changeName'</span>, <span class="string">'Tom'</span>)</span><br><span class="line">  store.commit(<span class="string">'changeName'</span>, <span class="string">'Tom'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;整理 Vue 3.0 组件选项和 Composition API 的对比&lt;/p&gt;
&lt;h1 id=&quot;Composition-API-的优点&quot;&gt;&lt;a href=&quot;#Composition-API-的优点&quot; class=&quot;headerlink&quot; title=&quot;Compositio
      
    
    </summary>
    
    
    
      <category term="Vue" scheme="https://www.chengjingchao.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>写在连续跑步 99 周</title>
    <link href="https://www.chengjingchao.com/2020/07/27/%E5%86%99%E5%9C%A8%E8%BF%9E%E7%BB%AD%E8%B7%91%E6%AD%A5-99-%E5%91%A8/"/>
    <id>https://www.chengjingchao.com/2020/07/27/%E5%86%99%E5%9C%A8%E8%BF%9E%E7%BB%AD%E8%B7%91%E6%AD%A5-99-%E5%91%A8/</id>
    <published>2020-07-26T16:14:15.000Z</published>
    <updated>2021-09-07T15:30:18.730Z</updated>
    
    <content type="html"><![CDATA[<p>从 2018 年的第 36 周 - 2020 年的第 30 周，达成连续跑步 99 周悦跑圈成就。<br>基本可以代表我来深圳有多久了。</p><h1 id="我的跑步经历"><a href="#我的跑步经历" class="headerlink" title="我的跑步经历"></a>我的跑步经历</h1><p>从 2016 年 4 月 1 日，开始跑步并记录，至今差不多 4 年多了。</p><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>最开始为啥要跑步，应该是当时在学校和室友几个一起商量早上起早跑步，然后就跑起来了。商量好的明天跑步，结果你早上不想起来，也有人早上一起叫你，也就不好意思再继续睡了。有伴一起跑，也就不知不觉养成习惯了。当时的跑步路线基本都在学校操场 3 - 5km，周末可能会一起去学校旁边的一个景区跑远一点 10km。</p><p>第一次参加跑步活动<br><img src="/img/life/running2.jpg" alt="running"><br><img src="/img/life/running.jpg" alt="running"></p><p>中间有过一段时间的全勤，后来以为膝盖受伤就跑的很少了。<br><img src="/img/life/running4.jpg" alt="running"></p><p>后来 17 年去厦门工作，基本维持一周一次的跑步频率。</p><p>再后来到了深圳，找到工作后，就又开始跑起来了，达到连续跑步 20 多周的时候便开始在意保持下去。</p><p>18 年 8 月 24 第一次突破半马，中间跟着一个大哥跑了很久。（谢谢那位大哥）</p><p>19 年 8 月 - 9 月 开始健身，为了少做有氧，就减少了跑量，那一两个月每次只跑了 500 - 1000m 。</p><p>现在的跑步状态基本每次 10 km+</p><p>从最开始跑步到现在的数据记录<br><img src="/img/life/running3.jpg" width = "300"/></p><hr/><h1 id="跑步装备"><a href="#跑步装备" class="headerlink" title="跑步装备"></a>跑步装备</h1><p>装备基本就是鞋可能挑一点，衣服倒无所谓。最开始跑步就穿的运动鞋校服。后来买了两双跑鞋，我应该不算是个装备党。</p><p>我买过的两双跑鞋</p><ul><li>Asics GT-2000 6</li><li>Adidas UltraBOOST 4.0</li></ul><p>新手入门可以买各大品牌的基础款跑鞋，先跑起来。后面再根据自己情况选择注重竞速的还是缓震的等等。</p><p>也许今年会买个运动手表⌚️，到时候可以写个评测。</p><h1 id="跑步软件"><a href="#跑步软件" class="headerlink" title="跑步软件"></a>跑步软件</h1><p>我一直用的<a href="https://www.thejoyrun.com/" target="_blank" rel="noopener">悦跑圈</a>记录。</p><p>也还有许多类似的软件都可以记录</p><ul><li>咕咚</li><li>Keep</li><li>Nike Run Club</li></ul><hr/><h1 id="跑步路线"><a href="#跑步路线" class="headerlink" title="跑步路线"></a>跑步路线</h1><p>体育馆、公园、景区、人行道和学校操场都跑过，跑过最多的应该是操场。现在的运动类软件基本都有附近的跑步路线推荐。</p><p>操场的好处</p><ul><li>橡胶跑道</li><li>跑不动了还可以跟着别人后面再坚持坚持✊</li></ul><hr/><h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1><p>跑步对我来说并不感到痛苦，并且也算是可以最直接得到正向反馈的一种运动方式。一方面身体会分泌激素，另一方面今天的配速比昨天快一点/距离比昨天远一点等。都是特别直接的自我激励，有了持续的正向反馈，也就很容易坚持下去。</p><p>期待有机会突破 <strong>42.195</strong> 的那一天。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从 2018 年的第 36 周 - 2020 年的第 30 周，达成连续跑步 99 周悦跑圈成就。&lt;br&gt;基本可以代表我来深圳有多久了。&lt;/p&gt;
&lt;h1 id=&quot;我的跑步经历&quot;&gt;&lt;a href=&quot;#我的跑步经历&quot; class=&quot;headerlink&quot; title=&quot;我的跑步
      
    
    </summary>
    
    
      <category term="生活" scheme="https://www.chengjingchao.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="生活" scheme="https://www.chengjingchao.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="运动" scheme="https://www.chengjingchao.com/tags/%E8%BF%90%E5%8A%A8/"/>
    
      <category term="跑步" scheme="https://www.chengjingchao.com/tags/%E8%B7%91%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>VS Code 与 Vim</title>
    <link href="https://www.chengjingchao.com/2020/06/13/VS-Code-%E4%B8%8E-Vim/"/>
    <id>https://www.chengjingchao.com/2020/06/13/VS-Code-%E4%B8%8E-Vim/</id>
    <published>2020-06-12T17:15:46.000Z</published>
    <updated>2020-08-03T16:56:19.334Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><blockquote><p>Vim 是从 vi 发展出来的一个文本编辑器。和 Emacs 并列成为类 Unix 系统用户最喜欢的编辑器。</p></blockquote><p><code>Vim</code> 提供了一系列很强大的编辑文本的操作方式，可以使用纯键盘完成编辑文本操作。再搭配许多插件可以配置成一个 IDE。但是 <code>Vim</code> 有着一个比较陡峭的学习曲线，并且不是开箱即用的。</p><p>如果没有特定的开发环境限制，可以使用</p><p>更漂亮易上手的编辑器 <code>(Visual Studio Code)</code> + 更流畅的编辑体验 <code>(Vim)</code></p><p>来提高编码效率，各取所长。</p><p>如今市面上几乎所有的 IDE 和编辑器都提供有 Vim 的相关插件。例如我所体验过的</p><ul><li>Sublime Text - <a href="https://github.com/guillermooo/Vintageous" target="_blank" rel="noopener">Vintageous</a>、<a href="https://github.com/guillermooo/Six" target="_blank" rel="noopener">Six</a></li><li>Visual Studio - <a href="https://github.com/VsVim/VsVim" target="_blank" rel="noopener">VsVim</a></li><li>Visual Studio Code - <a href="https://github.com/VSCodeVim/Vim" target="_blank" rel="noopener">Vim</a></li></ul><p>本文的所有操作都基于 <code>Visual Studio Code</code> +  <code>Vim 插件</code> 演示。(虽然我更喜欢 Sublime Text…)</p><hr><h1 id="先来点甜头-例子"><a href="#先来点甜头-例子" class="headerlink" title="先来点甜头 例子"></a>先来点甜头 例子</h1><p>举例几个实际例子，可以想像之前是怎么操作的</p><ol><li><p>字母顺序写反了 <code>ab</code> 写成了 <code>ba</code><br><img src="/img/vim/xp.gif" alt="running"></p></li><li><p>删除 HTML 元素中的内容 / 删除双引号之间的内容<br><img src="/img/vim/dit.gif" alt="running"></p></li></ol><p>…</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ol><li>打开 VS Code 的扩展商店</li><li>搜索 Vim</li><li>点击安装</li></ol><p><img src="/img/vim/vim-install.jpg" alt="running"></p><h1 id="Vim-模式"><a href="#Vim-模式" class="headerlink" title="Vim 模式"></a>Vim 模式</h1><p>模式意味着你的键盘会根据你所使用的模式获得不同的功能。也就是说，根据你所使用的模式，在键盘上键入一个按键会产生不同结果。</p><p>就像主键盘区上方的数字健可以直接按数字键 <code>1</code> 输入 1 也可以通过 <code>shift + 1</code> 输入 <code>！</code>，这样一个健位上就具有了不同的功能。</p><p>常用模式</p><ul><li><code>normal</code> 模式—— <strong>默认模式</strong>，可以通过键盘移动光标、删除字符、复制、粘贴等。</li><li><code>insert</code> 模式—— 正常的输入模式</li><li><code>visual</code> 模式—— 选中文本，类似通过鼠标选择文本</li></ul><p><code>Vim</code> 插件安装完成后，默认是 <code>normal</code> 模式，<code>normal</code> 模式下不能输入文本。按 <code>i</code> 键切换到 <code>insert</code> 模式。</p><p>如何判断编辑器当前所处模式</p><ul><li>通过光标样式判断</li><li>VS Code 底部 status 栏会显示当前模式</li></ul><p><img src="/img/vim/vscode-status.jpg" alt="running"></p><p>安装 Vim 后的副作用</p><ul><li><code>Ctrl + c</code> 不再是复制，而是切换到 <code>normal</code> 模式</li><li><code>Ctrl + v</code> 不再是粘贴，而是进入 <code>visual</code> 模式</li><li><code>Ctrl + f</code> 不再是搜索，而是向前滚动一页</li></ul><p>如果不希望 vim 改变这些健</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 禁用 vim 使用 Ctrl</span></span><br><span class="line"><span class="string">"vim.useCtrlKeys"</span>: <span class="literal">false</span>,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者更精细地控制 Vim 启用或禁用的映射，自行取舍。</span></span><br><span class="line"><span class="string">"vim.handleKeys"</span>: &#123;</span><br><span class="line">  <span class="string">"&lt;C-w&gt;"</span>: <span class="literal">false</span>, <span class="comment">// 禁用 Vim 使用 Ctrl w</span></span><br><span class="line">  <span class="string">"&lt;C-o&gt;"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">"&lt;C-n&gt;"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Tips: 禁用 Ctrl 键后，下面的 Vim 中包含 Ctrl 的操作将失效。</span><br></pre></td></tr></table></figure><h2 id="模式切换"><a href="#模式切换" class="headerlink" title="模式切换"></a>模式切换</h2><p>insert 切换 normal</p><ul><li><code>Esc</code></li><li><code>Ctrl + c</code></li><li><code>Ctrl + [</code></li></ul><p>normal 切换 insert</p><ul><li><code>i(insert)</code> 在当前字符前进入 <code>insert</code> 模式</li><li><code>a(append)</code> 在当前字符后进入 <code>insert</code> 模式</li><li><code>o(open)</code> 在当前行下开启新的一行进入 <code>insert</code> 模式</li><li><code>I</code> 在行首进入 <code>insert</code> 模式</li><li><code>A</code> 在行尾进入 <code>insert</code> 模式</li><li><code>O</code> 在当前行上开启新的一行进入 <code>insert</code> 模式</li><li><code>gi</code> 在最后一次 <code>insert</code> 的地方进入 <code>insert</code> 模式</li></ul><h2 id="normal-模式"><a href="#normal-模式" class="headerlink" title="normal 模式"></a>normal 模式</h2><p><code>normal</code> 模式下 <code>hjkl</code> 可以像键盘上的方向键一样上下左右移动光标而不是输入。<code>hjkl</code> 适用于短距离移动。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      ↑</span><br><span class="line">← h j k l →</span><br><span class="line">    ↓</span><br></pre></td></tr></table></figure><p><img src="/img/vim/hjkl.gif" alt="running"></p><p>数字搭配命令使用，快乐加倍。<br><code>{count}{command}</code></p><h3 id="快速移动"><a href="#快速移动" class="headerlink" title="快速移动"></a>快速移动</h3><p>单词之间移动<br>Vim 中的一个单词是</p><ul><li>字母和数字组成 （w、e、b、ge）</li><li>其他非空白字符序列 (W、E、B、GE)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello vim world</span><br><span class="line">HelloVimWorld()&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li><code>w</code> 移动至下个单词开头</li><li><code>e(end)</code> 移动至下个单词结尾 end</li><li><code>b(back)</code> 移动至上个单词开头 back</li><li><code>ge</code> 移动至上个单词末尾</li><li><code>gE</code></li></ul><p>以上命令还可大写，大小写的区别在于单词的范围不同。</p><ul><li>小写只由字母组成的单词</li><li>大写是以非空白符分割的单词</li></ul><p><code>{n}w/e/b/ge/gE</code> 跳转第几个单词</p><p><img src="/img/vim/w.gif" alt="running"></p><hr><p>行间搜索移动</p><ul><li><code>f{character}</code> 移至行中下一个出现的字符</li><li><code>F{character}</code> 移至行中上一个出现的字符</li><li><code>t{character}</code> 移至行中下一个出现的字符前</li><li><code>T{character}</code> 移至行中上一个出现的字符后</li></ul><p>重复查找上次的搜索命令，避免再次输入。</p><ul><li><code>;</code> 下一个</li><li><code>,</code> 上一个</li><li><code>{n};</code> 第 n 个</li></ul><p><img src="/img/vim/f.gif" alt="running"></p><hr><p>水平移动</p><ul><li><code>0</code> 移至行首</li><li><code>^</code> 移至行首的非空白字符</li><li><code>$</code> 移至行尾</li><li><code>g_</code> 移至行尾的非空白字符</li></ul><p><img src="/img/vim/0.gif" alt="running"></p><hr><p>垂直移动</p><ul><li><code>(</code> 上个句子</li><li><code>)</code> 下个句子</li><li><code>{</code> 上个段落</li><li><code>}</code> 下个段落</li><li><code>%</code> 移动光标到括号的另一半包括 () [] {}</li></ul><p>段落和句子都是以空行来分割。</p><p><img src="/img/vim/percent.gif" alt="running"></p><hr><p>页面移动</p><ul><li><code>gg</code> 第一行</li><li><code>G</code> 最后一行</li><li><code>{n}gg/{n}G</code> 移动到第 n 行</li><li><code>H(head)</code> 移动到屏幕顶部</li><li><code>M(middle)</code> 移动到屏幕中间</li><li><code>L(lower)</code> 移动到屏幕低部</li><li><code>zz</code> 当前行放到屏幕中间</li></ul><p><img src="/img/vim/gg.gif" alt="running"></p><hr><p>语义移动</p><ul><li><code>gd</code> 跳转到定义</li><li><code>gf</code> 跳转到导入的源文件</li><li><code>gh</code> 相当于将鼠标悬停在光标所在的位置。</li></ul><p><img src="/img/vim/gd.gif" alt="running"></p><h1 id="文本对象"><a href="#文本对象" class="headerlink" title="文本对象"></a>文本对象</h1><p>文本对象可以理解为范围，hjkl 移动是以一个字符为单位移动。<br>使用文本对象可以更大范围的移动操作</p><ul><li><code>w</code> 单词</li><li><code>s</code> 句子</li><li><code>p</code> 段落</li><li><code>(</code> 被 { 包围的块</li><li><code>{</code> 被 ( 包围的块</li><li><code>&#39;</code> 被 ‘ 包围的块</li><li><code>&quot;</code> 被 “ 包围的块</li><li><code>t</code> 被 html 标签包围的块</li></ul><h3 id="快速删除"><a href="#快速删除" class="headerlink" title="快速删除"></a>快速删除</h3><p>d (delete)</p><ul><li><code>dd</code> 删除当前行</li><li><code>{n}dd</code> 删除 n 行</li><li><code>df{character}</code> 从当前字符向后删除到目标字符</li><li><code>dF{character}</code> 从当前字符向前删除到目标字符</li><li><code>dt{character}</code> 从当前字符向后删除到目标字符前</li><li><code>dT{character}</code> 从当前字符向前删除到目标字符后</li><li><code>x = dl</code> 删除一个字符</li><li><code>X = dh</code> 删除前一个字符</li><li><code>{n}x</code> 删除 n 个字符</li></ul><p> 配合水平移动删除</p><ul><li><code>d^</code> 从当前字符删除到行首</li><li><code>d0</code> 从当前字符删除到行首</li><li><code>d$ = D</code> 从当前字符删除到行尾</li><li><code>dg_</code> 从当前字符删除到行尾</li></ul><p>配合文本对象删除</p><ul><li><code>dw</code> 从光标向后删除单词</li><li><code>d{n}w</code> 从光标向后删除 n 个单词</li><li><code>d{n}aw</code> 从当前单词向后删除 n 个单词</li><li><code>db</code> 从光标向前删除单词</li><li><code>diw</code> 删除单词</li><li><code>daw</code> 删除单词 + 单词后的空格</li><li><code>dit</code> 删除 html 标签包裹的内容</li><li><code>dat</code> 删除 html 标签 + 包裹的内容</li><li><code>di(</code> 删除 () 包裹的内容</li><li><code>da(</code> 删除 () + 包裹的内容</li><li><code>di{</code> 删除 {} 包裹的内容</li><li><code>da{</code> 删除 {} + 包裹的内容</li><li><code>di&quot;</code> 删除 “” 包裹的内容</li><li><code>da&quot;</code> 删除 “” + 包裹的内容</li><li><code>di&#39;</code> 删除 ‘’ 包裹的内容</li><li><code>da&#39;</code> 删除 ‘’ + 包裹的内容</li></ul><p>i - inner<br>a - around</p><h3 id="快速修改"><a href="#快速修改" class="headerlink" title="快速修改"></a>快速修改</h3><p>r (replace)</p><ul><li><code>r</code> 替一个字符</li></ul><p>c (change)</p><ul><li>c 的命令基本可以把上面快速删除中的 d 都替换成 c。唯一区别是 c 最后会进入到 insert 模式。</li></ul><p>s</p><ul><li><code>s = ch</code> 删除光标下的字符并进入 insert 模式</li><li><code>{n}s</code> 删除 n 个字符并进入 insert 模式</li><li><code>S</code> 删除当前行并进入 insert 模式</li><li><code>~</code> 切换单个字符大小写</li><li><code>g~</code> 当前行所有字符字符切换大小写</li></ul><h2 id="Command-模式"><a href="#Command-模式" class="headerlink" title="Command 模式"></a>Command 模式</h2><p>VS Code 只支持部分 Vim 的 command 命令。<br>运行命令以 : 开头</p><ul><li><code>:edit {relative-path-to-file} = :e {path}</code> 打开或创建文件 建议创建文件使用，打开文件使用 Ctrl + p<br>相对路径是相对的当前打开文件。</li></ul><p>保存和关闭文件</p><ul><li><code>:write = :w</code> 保存文件</li><li><code>:quit = :q</code> 关闭文件</li><li><code>:wq</code> 保存并关闭</li></ul><p>如果文件未更改或为只读则将失败。同样，:quit将关闭文件，但如果文件未保存的更改将失败。<br>后面加 ! 强制执行</p><ul><li><code>:wall = :wa</code> 保存所有文件</li><li><code>:qall = :qa</code> 关闭所有文件</li><li><code>:wqall = :wqa</code> 保存和关闭所有文件</li><li><code>:qall! = :qa!</code> 关闭所有文件不保存</li></ul><p>删除/修改/复制 d c y<br><code>:[range]command[options]</code></p><ul><li><code>:[range]delete [register]</code> 删除多行到寄存器</li><li><code>·@:</code> 重复上一个ex命令</li><li><code>·@@</code> 重复一次后，您可以继续重复此操作</li></ul><p>command 模式范围<br>:{start},{end} 起始行到结束行 1,2d<br>:{start},{offset} 起始行和偏移范围 1,+2d</p><ul><li><code>.</code> 当前行 .,+2d</li><li><code>%</code> 整个文件 %d</li><li><code>0</code> 文件开头 0,10d</li><li><code>$</code> 文件结尾 10,$d</li><li><code>:&#39;&lt;,&#39;&gt;</code></li></ul><h3 id="command-替换"><a href="#command-替换" class="headerlink" title="command 替换"></a>command 替换</h3><p><code>:[range]s/{pattern}/{substitute}/{flags}</code></p><ul><li><code>range</code> 范围</li><li><code>s/</code> 当前行</li><li><code>%s</code> 整个文件</li><li><code>pattern</code> 搜索模式 支持正则</li><li><code>substitute</code> 要替换的文本</li><li><code>flags</code> 选项<ul><li><code>-g</code> 全局</li><li><code>-i</code> 不区分大小写</li><li><code>-c</code> 确认每一次替换</li></ul></li><li><code>:s/led/gold</code> 当前行第一个 led =&gt; gold</li><li><code>:s/led/gold/g</code> 全局</li></ul><h3 id="command-模式搜索"><a href="#command-模式搜索" class="headerlink" title="command 模式搜索"></a>command 模式搜索</h3><p>搜索以 / 或 ？ 开头</p><ul><li><code>/{pattern}</code> 向后搜索 pattern 是个正则表达式</li><li><code>?{pattern}</code> 向前搜索</li><li><code>/ = n</code> 下一个匹配项 重复搜索</li><li><code>？= N</code> 上一个匹配项</li><li><code>gn</code> 选中下一个匹配项</li><li><code>gN</code> 选中上一个匹配项</li><li><code>dgn</code> 删除下一个匹配项</li><li><code>dgN</code> 删除上一个匹配项</li></ul><h2 id="Visual-模式"><a href="#Visual-模式" class="headerlink" title="Visual 模式"></a>Visual 模式</h2><blockquote><p>Visual 模式相当于用鼠标选择文本，但是在 Vim 中你可以用键盘来完成。</p></blockquote><ul><li><code>v</code> 逐字符选择文本</li><li><code>V</code> 逐行选择文本</li><li><code>Ctrl + v</code> 使用矩形块选择文本</li><li><code>o</code> 切换选择方向</li><li><code>d</code> 删除</li></ul><h2 id="insert-模式"><a href="#insert-模式" class="headerlink" title="insert 模式"></a>insert 模式</h2><ul><li><code>ctrl h</code> 删除上一个字符</li><li><code>ctrl w</code> 删除上一个单词</li><li><code>ctrl u</code> 删除当前行</li><li><code>ctrl a</code> 移动到行首</li><li><code>ctrl e</code> 移动到行尾</li><li><code>ctrl b</code> 向前移动</li><li><code>ctrl f</code> 向后移动</li></ul><p>终端中也可以使用</p><h1 id="复制粘贴"><a href="#复制粘贴" class="headerlink" title="复制粘贴"></a>复制粘贴</h1><p>在 Vim 中</p><ul><li><code>y</code> 复制</li><li><code>Y</code> 复制当前行</li><li><code>p</code> 在当前字符后粘贴</li><li><code>p</code> 在当前字符前粘贴</li><li><code>yyp</code> 重复当前行</li><li><code>ddp</code> 交换上下行</li><li><code>xp</code> 交换字符</li><li><code>yl</code> 复制当前字符</li></ul><p>配合文本对象使用</p><ul><li><code>yaw</code> 复制一个单词</li><li><code>yas</code> 复制一个单词</li><li><code>yi(</code></li><li><code>yip</code></li><li><code>yap</code></li></ul><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>寄存器是一个特殊的剪贴板，你可以选择在其中一次保存多个内容。就像有很多盒子，你可以自由的选择将复制、删除的内容放在哪个盒子中，需要的时候可以自由拿出来(粘贴)。Vim 的删除、复制与粘贴命令均需要使用 Vim 寄存器。</p><p>通过在命令前加 <code>&quot;寄存器名</code> 前缀的方式可指定寄存器，否则 Vim 将缺省使用无名寄存器。</p><p>若想在 Vim 和操作系统外部程序间共享复制内容，则必须使用 Vim 系统剪贴板。</p><ul><li><code>&quot;&quot;</code> 无名寄存器 默认使用「无名寄存器」<code>&quot;&quot;p === p</code></li><li><code>&quot;[a-z]</code> 有名寄存器，以 26 个英文字母命名，使用小写字母引用有名寄存器会覆盖该寄存器的原有内容，而用大写字母引用则会将新内容 追加 到该寄存器的原有内容之后。</li></ul><p>特殊寄存器</p><ul><li><code>&quot;0</code> 复制寄存器</li><li><code>&quot;+</code> 系统剪贴板</li><li><code>&quot;%</code> 当前文件名</li><li><code>&quot;.</code> 上次插入的文本</li><li><code>&quot;[1-9]</code> 存储最后 9 次删除或更改命令的内容</li><li><code>:reg {name}</code> 查看寄存器内容</li></ul><h1 id="Vim-宏-marcro）"><a href="#Vim-宏-marcro）" class="headerlink" title="Vim 宏 (marcro）"></a>Vim 宏 (marcro）</h1><blockquote><p>可以看作是一些系列命令的集合，可以录制一系列操作然后用于「回放」</p></blockquote><p>在 normal 模式下，按下 <code>q{register}</code> 后开始进入宏录制状态，<code>VS Code</code> 编辑器左下角会显示 <code>Recording</code></p><ul><li><code>q{register}</code> 开始录制 再按 <code>q</code> 结束录制 录制保存在寄存器中</li><li><code>@a</code> 回放保存在 <code>a</code> 寄存器中的操作</li><li><code>@@</code> 重复上次回放</li><li><code>{n}@{register}</code></li></ul><p>Example</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rusty sword,obsidian dagger,silver poniard,broadsword 转换成</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>rusty sword<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>obsidian sword<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>silver poniard<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>broadsword poniard<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><p>VS Code 中内置了许多有用的 Vim <a href="https://github.com/VSCodeVim/Vim#-emulated-plugins" target="_blank" rel="noopener">插件</a>。</p><h2 id="vim-suround"><a href="#vim-suround" class="headerlink" title="vim-suround"></a>vim-suround</h2><p>默认启用</p><ul><li><code>ds</code> 删除</li><li><code>cs</code> 更改</li><li><code>ys</code> 添加</li></ul><p>Example</p><ul><li><code>ds&#39;</code> 删除周围的 <code>&#39;</code></li><li><code>ds(</code></li><li><code>ds[</code></li><li><code>ds{</code></li><li><code>cs&quot;&#39;</code> 把 <code>&quot;</code> 改成 <code>&#39;</code></li></ul><h2 id="vim-sneak"><a href="#vim-sneak" class="headerlink" title="vim-sneak"></a>vim-sneak</h2><p>默认禁用，setting.json 中 <code>vim.sneak: true</code> 开启。</p><ul><li><code>s{char}{char}</code> 类似 f 命令，不过现在 s 可以搜索两个字符更容易定位。</li><li><code>S{char}{char}</code> 向上搜索</li></ul><h2 id="Input-Method"><a href="#Input-Method" class="headerlink" title="Input Method"></a>Input Method</h2><p>在插入模式输入中文再进入到 normal 模式后，需要切换回英文输入法。<code>Input Method</code> 避免了这种问题。<br>使用方法参考 <a href="https://www.zhihu.com/question/303850876" target="_blank" rel="noopener">如何解决VSCode Vim中文输入法切换问题？</a></p><h2 id="vim-easymotion"><a href="#vim-easymotion" class="headerlink" title="vim-easymotion"></a>vim-easymotion</h2><p>默认禁用，setting.json 中 <code>vim.easymotion: true</code> 开启。</p><p>easymotion 试图通过消除记数来简化 Vim 中运动的使用。当使用 easymotion 时，它会使用叠加层（在相关文字上方）标识。输入该标识跳转过去。easymotion 适用于四处移动。</p><p>“vim.leader”: “space” 可以自行映射 leader 键盘。</p><ul><li><code>&lt;leader&gt;&lt;leader&gt;w</code> 标记后面所有单词的开头</li><li><code>&lt;leader&gt;&lt;leader&gt;b</code></li><li><code>&lt;leader&gt;&lt;leader&gt;bdw</code></li><li><code>&lt;leader&gt;&lt;leader&gt;e</code></li><li><code>&lt;leader&gt;&lt;leader&gt;ge</code></li><li><code>&lt;leader&gt;&lt;leader&gt;j</code></li><li><code>&lt;leader&gt;&lt;leader&gt;k</code></li><li><code>&lt;leader&gt;&lt;leader&gt;f{char}</code></li><li><code>&lt;leader&gt;&lt;leader&gt;F{char}</code></li><li><code>&lt;leader&gt;&lt;leader&gt;t{char}</code></li><li><code>&lt;leader&gt;&lt;leader&gt;T{char}</code></li><li><code>&lt;leader&gt;&lt;leader&gt;s{char}</code></li></ul><h1 id="Setting"><a href="#Setting" class="headerlink" title="Setting"></a>Setting</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// VS Code setting.json 中设置</span></span><br><span class="line"><span class="string">"editor.lineNumbers"</span>: <span class="string">"relative"</span>, <span class="comment">// 设置相对行号</span></span><br><span class="line"><span class="string">"vim.cursorStylePerMode.normal"</span>: <span class="string">"underline"</span>, <span class="comment">// 设置 normal 模式下光标为下划线</span></span><br><span class="line"><span class="string">"vim.leader"</span>: <span class="string">"&lt;Space&gt;"</span>, <span class="comment">// 自定义空格 leader 键 默认是 /</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义映射 使其更适应你的工作方式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. insert 模式下输入 jj 进入到 normal 模式 jj =&gt; ESC</span></span><br><span class="line"><span class="string">"vim.insertModeKeyBindingsNonRecursive"</span>: [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"before"</span>: [<span class="string">"j"</span>, <span class="string">"j"</span>],</span><br><span class="line">    <span class="string">"after"</span>: [<span class="string">"&lt;ESC&gt;"</span>]</span><br><span class="line">  &#125;</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 更快速的移动 normal 模式下 J =&gt; 5j，K =&gt; 5k</span></span><br><span class="line"><span class="string">"vim.normalModeKeyBindingsNonRecursive"</span>: [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"before"</span>: [<span class="string">"J"</span>],</span><br><span class="line">    <span class="string">"after"</span>: [<span class="string">"5"</span>, <span class="string">"j"</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"before"</span>: [<span class="string">"K"</span>],</span><br><span class="line">    <span class="string">"after"</span>: [<span class="string">"5"</span>, <span class="string">"k"</span>]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 映射到 VS Code 的命令 space + w =&gt; workbench.action.files.save</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">"before"</span>: [<span class="string">"leader"</span>, <span class="string">"w"</span>],</span><br><span class="line">    <span class="string">"commands"</span>: [</span><br><span class="line">        <span class="string">"workbench.action.files.save"</span>,</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><a href="https://github.com/VSCodeVim/Vim#key-remapping" target="_blank" rel="noopener">VS Code Vim 有趣的映射</a></p><!-- 使Vim更加有效，重要的一点就是要牢记您的开发工作流程。时不时地重新访问Vim配置，并添加新的映射来增强您的工作方式。因此，从现在开始要注意，并保持您的Vim配置剃须刀锋利。 --><h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><ul><li><code>Ctrl + Shift + p</code> 打开命令面板输入 <code>Toggle Vim Mode</code> 快速切换 Vim 开关</li><li><code>.</code> 重复最后一次修改</li><li><code>&gt;&gt;</code> 向右缩进</li><li><code>&lt;&lt;</code> 向左缩进</li><li><code>u</code> 撤销</li><li><code>*</code> 跳转到下一个相同单词</li><li><code>#</code> 跳转到上一个相同单词</li></ul><h2 id="Chrome-插件-Vimium"><a href="#Chrome-插件-Vimium" class="headerlink" title="Chrome 插件 Vimium"></a>Chrome 插件 Vimium</h2><p><a href="https://chrome.google.com/webstore/detail/dbepggeogbaibhgnhhndojpepiihcmeb" target="_blank" rel="noopener">Vimium</a> 提供了在浏览器上使用 Vim 功能</p><ul><li><code>j</code> 向下移动网页</li><li><code>k</code> 向上移动网页</li><li><code>gg</code> 移动到网页顶部</li><li><code>G</code> 移动到网页底部</li><li><code>J</code> 上一个标签页</li><li><code>K</code> 下一个标签页<br>…</li></ul><h1 id="让键盘适应工具"><a href="#让键盘适应工具" class="headerlink" title="让键盘适应工具"></a>让键盘适应工具</h1><p>可以选择 ESC 和 Ctrl 比较容易触碰的键盘，或者把 CapsLock 映射成 Ctrl。</p><p>⌨️</p><ul><li>HHKB</li><li>Poker2</li></ul><h1 id="我使用-Vim-几个阶段"><a href="#我使用-Vim-几个阶段" class="headerlink" title="我使用 Vim 几个阶段"></a>我使用 Vim 几个阶段</h1><p>从第一次接触到现在也有 3-4 年左右了吧。</p><ol><li>最开始在学校的时候看网上的一个视频课程，里面用的 <code>Sublime + Vim</code> 插件。算是我的 <code>Vim</code>启蒙。导致我到现在一直对 <code>Sublime Text</code> 情有独钟。当时基本只会 <code>hjkl dd gg p</code> 一些简单的操作。</li><li>学了文本对象，<code>f{char} t{char} d/c{文本对象}</code> 等 稍微熟练了些。</li><li>开始了解 <code>VS Code</code> 与 <code>Vim</code> 的搭配。不得不说 <code>VS Cod</code> 中的 <code>Vim</code> 比 <code>Sublime</code> 中的 <code>Vim</code>功能强大了不少。</li></ol><p>有时可能同时会有同事在我电脑上操作，会很不习惯。这种时候 <code>toggle vim mode</code> 就很好使了。</p><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>先挑选对自己有用的用到日常开发中，不要一口一个大胖子。<br><code>Vim</code> 实在是太强大了，写这篇文章时，也有很多是现学(抄)的，熟能生巧。<br><code>VS Code</code> 和 <code>Vim</code> 的结合会有一些功能重合或冲突的地方根据自己习惯取舍，最适合自己的就是最好的。</p><h1 id="参考链接-🔗"><a href="#参考链接-🔗" class="headerlink" title="参考链接 🔗"></a>参考链接 🔗</h1><p><a href="https://vimjc.com/" target="_blank" rel="noopener">https://vimjc.com/</a><br><a href="https://github.com/VSCodeVim" target="_blank" rel="noopener">https://github.com/VSCodeVim</a><br><a href="https://coding.imooc.com/learn/list/50.html" target="_blank" rel="noopener">https://coding.imooc.com/learn/list/50.html</a><br><a href="https://www.zhihu.com/question/303850876" target="_blank" rel="noopener">https://www.zhihu.com/question/303850876</a><br><a href="https://www.barbarianmeetscoding.com/blog/2019/02/08/boost-your-coding-fu-with-vscode-and-vim" target="_blank" rel="noopener">https://www.barbarianmeetscoding.com/blog/2019/02/08/boost-your-coding-fu-with-vscode-and-vim</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;背景介绍&quot;&gt;&lt;a href=&quot;#背景介绍&quot; class=&quot;headerlink&quot; title=&quot;背景介绍&quot;&gt;&lt;/a&gt;背景介绍&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Vim 是从 vi 发展出来的一个文本编辑器。和 Emacs 并列成为类 Unix 系统用户最喜欢
      
    
    </summary>
    
    
      <category term="编辑器" scheme="https://www.chengjingchao.com/categories/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
    
      <category term="Vim" scheme="https://www.chengjingchao.com/tags/Vim/"/>
    
      <category term="编辑器" scheme="https://www.chengjingchao.com/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://www.chengjingchao.com/2020/06/01/hello-world/"/>
    <id>https://www.chengjingchao.com/2020/06/01/hello-world/</id>
    <published>2020-06-01T15:27:59.976Z</published>
    <updated>2020-06-01T15:57:35.680Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
</feed>
